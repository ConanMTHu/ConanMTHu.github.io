<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Tommy'Blog]]></title>
  <subtitle><![CDATA[Tommy]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://hmttommy.com/"/>
  <updated>2016-01-21T05:52:15.000Z</updated>
  <id>http://hmttommy.com/</id>
  
  <author>
    <name><![CDATA[Tommy]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Swift 面向Protocol编程浅析:Inheritence-Composition-Protocol]]></title>
    <link href="http://hmttommy.com/2016/01/14/protocolMVVM/"/>
    <id>http://hmttommy.com/2016/01/14/protocolMVVM/</id>
    <published>2016-01-14T02:03:22.000Z</published>
    <updated>2016-01-21T05:52:15.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u5F15"><a href="#u5F15" class="headerlink" title="引"></a><font color="IndianRed">引</font></h2><p>记得从大学学编程开始,对于软件编程听的最多的就是<code>面向对象编程(Object Oriented Programming，OOP)</code>了,它的三大特征:封装,继承,多态.而Swift倡导的<code>面向协议编程(Protocol-oriented programming,POP)</code>是OOP的一个范例,我理解为”封装+协议*结构体+扩展”(Swift2.0开始,你可以扩展一个<code>protocol</code>)  </p>
<p><a href="https://developer.apple.com/videos/play/wwdc2015-408/" target="_blank" rel="external">WWDC:Protocol-Oriented Programming in Swift</a>开头<code>Classess Are Awesome</code>,指出OOP中的<code>Classes</code>提供了:数据的封装、访问控制、抽象化、命名空间等,但这些都是<code>Classes</code>才特有的属性吗?事实上,这些都是<code>类型(Type)</code>的所有属性,<code>Classes</code>只是<code>Type</code>的一种实现方法,在Swift中<code>I can do all that with structs and enums</code>(Swift的标准库组成:55个Protocols和102个Structs),这一点可以理解为封装性.而继承和多态,是<code>struct</code>和<code>enum</code>不具备的,它则是通过遵守<code>protocol</code>来实现.  </p>
<p>但,这些是为了说明让我们放弃<code>OOP</code>吗?这是不可能的….想想<code>UIKit</code>….记得刚开始用Swift写项目时,总是告诫自己,不能只是机械的把<code>objc 翻译成 swift</code>.<font color="IndianRed">实际开发项目中,<code>ViewControl</code>和<code>View</code>基本都是使用系统的框架,通过继承来实现,无论如何的自定义,都是要围绕苹果的那一套来,OC与swift在这一块保持一致;但在<code>model</code>和<code>handle/viewModel/manager</code>这一块,更多的通过POP实现,后面会通过一个例子来说明.</font>(PS:在oc中,我们体会的是OOP/FRP(参考一下<code>RAC</code>),那Swift就是OOP/FRP(参考一下<code>RxSwift</code>)/POP;在oc中对于Protocols的理解更多的是<code>UIAppplicationDelegate,UITableViewDelegete,NSCopying,UITextFieldDelegate....</code>,而Swift中Protocols则被赋予了更多的功能和意义:”可定义属性,可组合,可继承,可扩展,支持泛型,支持类/结构体/枚举”).在<a href="http://www.cocoachina.com/swift/20150729/12824.html" target="_blank" rel="external">Swift面向协议编程初探</a>中,bz总结的一句话,非常nice:<br><code>面向对象编程和面向协议编程最明显的区别在于程序设计过程中对数据类型的抽取(抽象)上，面向对象编程使用类和继承的手段，数据类型是引用类型</code><br><code>面向协议编程使用的是遵守协议的手段，数据类型是值类型（Swift中的结构体或枚举)</code><br>PS:<code>值类型</code>和<code>引用类型</code>的区别这里不作详叙,可参考<a href="http://swift.gg/2015/08/14/friday-qa-2015-07-17-when-to-use-swift-structs-and-classes/" target="_blank" rel="external">Swift：什么时候使用结构体和类</a>  </p>
<h2 id="u8BA8_u538C_u7684_u201D_u4E0A_u5E1D_u201D_28Inheritence_29"><a href="#u8BA8_u538C_u7684_u201D_u4E0A_u5E1D_u201D_28Inheritence_29" class="headerlink" title="讨厌的”上帝”(Inheritence)"></a><font color="IndianRed">讨厌的”上帝”(Inheritence)</font></h2><p><code>继承</code>带给我们最大的问题,可能就是常常会构造出所谓的<code>God类/super类</code>,带来的坏处也随之可见:</p>
<ul>
<li>一层一层一层的传递下去,它的任何行为都会影响它的所有小弟;  </li>
<li>有的小弟继承了无用的属性和方法;  </li>
<li>不方便扩展,差别不大的同类上帝,直接拷贝一遍代码?<br>特别喜欢<a href="http://casatwy.com/tiao-chu-mian-xiang-dui-xiang-si-xiang-yi-ji-cheng.html" target="_blank" rel="external">田伟宇博客:跳出面向对象思想(一) 继承</a>中提到关于<code>继承</code>的要点之一:父类的所有变化，都需要在子类中体现，也就是说此时耦合已经成为需求.(他的文章非常nice,在架构这一块的写的系列文章值得深读)so,LZ的观点也是<code>万不得已不要用继承,优先考虑组合</code>!<br>注:在objc中,更多的是用<code>组合(Composition)</code>,在Swift中则是<code>协议&gt;组合&gt;继承</code>.后面会举例说明.<br>再注:全文的Demo在<a href="https://github.com/ConanMTHu/SwiftProtocol" target="_blank" rel="external">这里</a><br>我们通过两张图对比一下:引用自<a href="http://www.kancloud.cn/luofei614/programmer_talk_life/107498" target="_blank" rel="external">程序员聊人生</a>  <a id="more"></a>
<img src="http://7qn7zn.com1.z0.glb.clouddn.com/%E7%BB%A7%E6%89%BF%E7%9A%84%E9%94%99.png" alt="">  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">    <span class="keyword">var</span> type: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">eat</span><span class="params">()</span></span>&#123;&#125; </span><br><span class="line"><span class="comment">//    func fly()&#123;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span>: <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">fly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Bird can fly"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Preson</span>: <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"person can speak"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fish</span>: <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">swimming</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"fish can swimming"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设超人会飞不会游泳,复制飞的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperMan</span>: <span class="title">Preson</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">speak</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"superman also speak"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">fly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"superman also fly"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperFishMan</span>: <span class="title">SuperMan</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">swimming</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"superfishman can swimming"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"> + objc/<span class="type">Swift</span>都不存在多继承,会游泳的超人,这时要复制游的方法,到这里已经是第四层了...高耦合    </span><br><span class="line"> + 也不好直接把fly()定义到父类<span class="type">Animal</span>中,等于强加限制.因为通过继承,抽象出共同的性质,<span class="type">Bird</span>/<span class="type">Preson</span>/<span class="type">Fish</span>都是动物(人是高级动物),它们都有属性name和type,都具有eat()的行为,但fly()不是所有动物共有的      </span><br><span class="line"> + 这时来了一个外星生物,它不属于<span class="type">Animal</span>,但是拥有<span class="type">Animal</span>及其子类所有的属性和行为(方法),怎么办?`上帝类`都帮不了你了,又走上了重复复制之路!&lt;div align=<span class="string">"center"</span>&gt;![](http:<span class="comment">//7qn7zn.com1.z0.glb.clouddn.com/zhuangtou.gif)&lt;/div&gt;  </span></span><br><span class="line">    </span><br><span class="line">有句话是咋说的:我们区分鸟和鱼,不是因为它们的名字是鸟/鱼,而是通过它们表现的行为,有点乱,^<span class="number">_</span>^.把所有的行为拆分出来,通过搭积木的形式组合出来,你具备什么就拿什么,那么你的身份也就随之浮现了.  </span><br><span class="line">![](http:<span class="comment">//7qn7zn.com1.z0.glb.clouddn.com/protocol_zuhe.png)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>protocol Property {<br>    var name: String {get}<br>    var type: String {get}<br>}</p>
<p>extension Property {<br>    var name: String {<br>        return “超人”<br>    }<br>    var type: String {<br>        return “外星类”<br>    }<br>}</p>
<p>protocol Speaker {<br>    func speak()<br>}</p>
<p>protocol Flyer {<br>    func fly()<br>}</p>
<p>protocol Swimer {<br>    func swimming()<br>}</p>
<p>struct SuperMan {<br>}</p>
<p>extension SuperMan: Property,Flyer,Speaker {<br>    func fly() {<br>        print(“superman also fly”)<br>    }<br>    func speak() {<br>        print(“superman also speak”)<br>    }<br>}</p>
<p>struct SuperFishMan {<br>}</p>
<p>extension SuperFishMan: Property,Flyer,Speaker,Swimer {<br>    var name: String {<br>        return “超水人”// 好蠢的名字…<br>    }<br>    func fly() {<br>        print(“…”)<br>    }<br>    func speak() {<br>        print(“…”)</p>
<pre><code>}
func swimming() {
    print(&quot;....&quot;)
}
</code></pre><p>}<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="label"> + objc中,还是可以定义一个父类Animal的,LZ现在基本都是写Swift了,就直接定义了一个protocol:<span class="escape">`P</span></span>roperty<span class="escape">`,</span>在扩展中写好默认实现  </span><br><span class="line"> + 消灭了<span class="escape">`上</span>帝类<span class="escape">`,</span>全部都定义为protocol,用到什么就拼接什么,真的就够搭积木一样便捷...  </span><br><span class="line">  </span><br><span class="line">## &lt;font color=<span class="string">"IndianRed"</span>&gt;组合(Composition),哎哟不错&lt;/font&gt;  </span><br><span class="line">第一个例子属于对于<span class="escape">`m</span>odel<span class="escape">`定</span>义,接下来看一个<span class="escape">`v</span>iew<span class="escape">`层</span>所表现出的问题.  </span><br><span class="line">手机QQ底部tabbar的三个标签首页都带有一个头像控件,最开始我们采取继承的形式来实现一个<span class="escape">`b</span>aseVC`</span><br></pre></td></tr></table></figure></p>
<p>class KQUserAvatarView: UIView {<br>}</p>
<p>class KQBaseViewController: UIViewController {<br>    var userAvatarView: KQUserAvatarView!</p>
<pre><code>func setupUserAvatarView() {
}

func clickOnAvatarView() {
}
</code></pre><p>}<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> + 新需求,希望第一、第二个标签页的头像加上大V的标志,第三页保持不变,此刻高耦合,父类改动牵动三个子类/甚至更多子类的变化.或许你直接在父类中添加改变样式的方法,那么那些不需要改变的子类也就直接继承了无用的方法...  </span><br><span class="line"> + 又来个需求,我需要一个父类是<span class="escape">`U</span>ITableViewController<span class="escape">`的</span>新<span class="escape">`K</span>QUserAvatarView<span class="escape">`,</span>瞬间傻眼...只能复制代码再创造一个上帝了  </span><br><span class="line"> + 这种情况还只是一个view的创建,如果是好几个组合view的组成,那么VC中的代码简直就是灾难...</span><br><span class="line">  </span><br><span class="line">在objc/Swift1.<span class="number">2</span>之前的,我们用<span class="escape">`组</span>合来代替继承<span class="escape">`,</span>这是非常常见的一种做法.借助中间件,解耦+转移逻辑代码,减轻VC的负担.</span><br></pre></td></tr></table></figure></p>
<p>class KQUserAvatarView: UIView {<br>    var btn: UIButton!</p>
<pre><code>override init(frame: CGRect) {
    super.init(frame: frame)
}

required init?(coder aDecoder: NSCoder) {
    fatalError(&quot;init(coder:) has not been implemented&quot;)
}
</code></pre><p>}</p>
<p>typealias ClickButtonAction = () -&gt; ()<br>class KQUserAvatarViewManager {<br>    var userAvatarView: KQUserAvatarView!<br>    var tapHandle: ClickButtonAction?</p>
<pre><code>func setupUserAvatarViewAtContainView(view: UIView,tapHandle: ClickButtonAction?) {
    userAvatarView = KQUserAvatarView(frame: CGRect(x: 100, y: 100, width: 100, height: 100))
    userAvatarView.backgroundColor = UIColor.orangeColor()
    view.addSubview(userAvatarView)
    self.tapHandle = tapHandle
    userAvatarView.btn.addTarget(self, action: &quot;clickOnAvatarView&quot;, forControlEvents: .TouchUpInside)
}

func clickOnAvatarView() {
    if let block = self.tapHandle {
        block()
    }
}
</code></pre><p>}</p>
<p>class ViewController: UIViewController {<br>    var manager: KQUserAvatarViewManager!</p>
<pre><code>override func viewDidLoad() {
    super.viewDidLoad()
    manager.setupUserAvatarViewAtContainView(self.view) {
        print(&quot;点击了按钮&quot;)
    }

}

override func didReceiveMemoryWarning() {
    super.didReceiveMemoryWarning()
    // Dispose of any resources that can be recreated.
}
</code></pre><p>}<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> + 哪个页面需要头像控件,直接创建一个<span class="code">`KQUserAvatarViewManager`</span>对象进行引用就行,实现了解耦    </span><br><span class="line"> + 多个view对应对个manager,很好的给VC进行了瘦身  </span><br><span class="line"> + 题外话:前端时间看了阳神的[<span class="link_label">iOS 开发中的 Self-Manager 模式</span>](<span class="link_url">http://blog.sunnyxx.com/2015/12/19/self-manager-pattern-in-ios/</span>),评论也看了...对于文章所诉的观点,LZ我也是赞同评论中提议的创建一个<span class="code">`ViewManager`</span>,在它里面处理点击事件或者delegate/block回调给VC来处理...至于<span class="code">`这个 Avatar View 在 App 的各个地方都可能粗线，而且行为一致，那就意味着事件处理的 block，要散落在各个页面中，同时也带来了很多“只是为向上一层级转发事件”的 “Middle Man”`</span>这句话,我认为,除非block中的处理事件完全一致(都是加载同一个model,都是push/modal推出视图),否则做不到逻辑代码只有一份的情况,它还是得分散在各个VC中做对应的跳转...(个人观点,不喜勿喷)  </span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="header">## &lt;font color="IndianRed"&gt;POP的实现(Protocol)&lt;/font&gt;  </span></span><br><span class="line">如果说组合的缺点,调用时必须通过中间变量,管理它的创建和释放,多了一层构造(缺点是相对的,在POP之前都这样用..优点都是对比出来的)</span><br></pre></td></tr></table></figure></p>
<p>typealias ClickButtonAction = () -&gt; ()<br>class KQUserAvatarView: UIView {<br>    var btn: UIButton!<br>    var tapBlock: ClickButtonAction?</p>
<pre><code>override init(frame: CGRect) {
    super.init(frame: frame)
    btn = UIButton(type: .ContactAdd)
    btn.frame = CGRect(x: 0, y: 0, width: 40, height: 40)
    self.addSubview(btn)

    btn.addTarget(self, action: &quot;clickOnAvatarView&quot;, forControlEvents: .TouchUpInside)
}

func clickOnAvatarView() {
    if let blcok = tapBlock {
        blcok()
    }
}

required init?(coder aDecoder: NSCoder) {
    fatalError(&quot;init(coder:) has not been implemented&quot;)
}
</code></pre><p>}</p>
<p>protocol UserAvatarViewAble: class {<br>    var userAvatarView: KQUserAvatarView! {get set}<br>    func setupUserAvatarView(tapHandle: ClickButtonAction?)<br>}</p>
<p>extension UserAvatarViewAble where Self: UIViewController {<br>    //  扩展不能实现储存属性<br>    func setupUserAvatarView(tapHandle: ClickButtonAction?) {<br>        userAvatarView = KQUserAvatarView(frame: CGRect(x: 100, y: 100, width: 100, height: 100))<br>        userAvatarView.backgroundColor = UIColor.orangeColor()<br>        self.view.addSubview(userAvatarView)<br>        userAvatarView.tapBlock = tapHandle<br>    }<br>}</p>
<p>class ViewController: UIViewController, UserAvatarViewAble {<br>    var userAvatarView: KQUserAvatarView!</p>
<pre><code>override func viewDidLoad() {
    super.viewDidLoad()
    setupUserAvatarView {
        print(&quot;点击了按钮&quot;)
    }
}

override func didReceiveMemoryWarning() {
    super.didReceiveMemoryWarning()
    // Dispose of any resources that can be recreated.
}
</code></pre><p>}<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> + 定义protocol,通过extension来实现协议,消除了中间变量  </span><br><span class="line"> + <span class="code">`where Self: UIViewController`</span>用来规定<span class="code">`只有采纳协议的类型满足这些限制条件时，才能获得协议扩展提供的默认实现`</span>.这个协议设计的就是作为VC的子视图控件,因此可以用<span class="code">`UIViewController`</span>来直接限定,so<span class="code">`self.view.addSubview(xxx)`</span>可以直接在协议的扩展中完成.  </span><br><span class="line"> + <span class="code">`UIViewController`</span>属于类类型,因此协议<span class="code">`UserAvatarViewAble`</span>必须用<span class="code">`class`</span>关键字来修饰只能被类类型使用.还有就是在<span class="code">`setupUserAvatarView`</span>方法中对属性变量进行了修改,如果是结构体/枚举采用了协议,必须用<span class="code">`mutating`</span>关键字来修饰方法,否则就会报错...可以看看这个错误[<span class="link_label">Protocol Extension, Mutating Function</span>](<span class="link_url">http://stackoverflow.com/questions/32488726/protocol-extension-mutating-function</span>)  </span><br><span class="line">  </span><br><span class="line">这样看上去是不是很简洁易用?在Swift中很多场景都能通过它来实现.比如:检查手机号码,用户名的正则表达式判断..../颜色,图片的转换...等一系列的逻辑方法.  </span><br><span class="line">LZ之前objc项目中就存在各种:<span class="code">`WCXxxUtil`</span>,<span class="code">`WCXxxHandle`</span>,<span class="code">`WCRegularUtil`</span>...  </span><br><span class="line">迁移到Swift中就类似[<span class="link_label">Mixins and Traits in Swift 2.0</span>](<span class="link_url">http://matthijshollemans.com/2015/07/22/mixins-and-traits-in-swift-2/</span>)写到的:</span><br></pre></td></tr></table></figure></p>
<p>protocol ValidatesUsername {<br>    func isUsernameValid(password: String) -&gt; Bool<br>}</p>
<p>extension ValidatesUsername {<br>    func isUsernameValid(username: String) -&gt; Bool {<br>        if /<em> username too short </em>/ {<br>            return false<br>        } else if /<em> username has invalid characters </em>/ {<br>            return false<br>        } else {<br>            return true<br>        }<br>    }<br>}</p>
<p>class LoginViewController: UIViewController, ValidatesUsername, ValidatesPassword {<br>    @IBAction func loginButtonPressed() {<br>        if isUsernameValid(usernameTextField.text!) &amp;&amp;<br>            isPasswordValid(passwordTextField.text!) {<br>                // proceed with login<br>        } else {<br>            // show alert<br>        }<br>    }<br>}<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protocol拆分了各种工具,extension实现默认设定,拿来即用,方便`无污染`.  </span><br><span class="line">  </span><br><span class="line"><span class="comment">## &lt;font color="IndianRed"&gt;POP在ViewModel中的体现&lt;/font&gt;  </span></span><br><span class="line">实现这样一个功能,写一个通讯录,要有头像和姓名-电话号码...  </span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span>protocol层(不记得在哪里看到,对于协议的命令用形容词,果然IT最难的是命名...)<span class="keyword">*</span><span class="keyword">*</span></span><br></pre></td></tr></table></figure></p>
<p>protocol PersonPresentAble {<br>    var nameTelText: String {get}<br>}</p>
<p>// 可以通过扩展提供默认实现…可用可不用<br>extension PersonPresentAble {<br>    var nameTelText: String {<br>        return “hehe”<br>    }<br>}</p>
<p>typealias TapImageViewAction = () -&gt; ()<br>protocol ImagePresentAble {<br>    var showImage: UIImage? {get}<br>    var tapHandle: TapImageViewAction? {get}<br>}<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span>ViewModel层<span class="keyword">*</span><span class="keyword">*</span></span><br></pre></td></tr></table></figure></p>
<p>struct PersonModel {<br>    var firstName: String<br>    var lastName: String<br>    var fullName: String {<br>        return lastName + firstName<br>    }<br>    var telPhone: String<br>    var avatarImageUrl: String?<br>}</p>
<p>typealias TelPersonViewModelAble = protocol<personpresentable,imagepresentable><br>struct TelPersonViewModel: TelPersonViewModelAble {<br>    var telPerson: PersonModel<br>    var nameTelText: String<br>    var showImage: UIImage?<br>    var tapHandle: TapImageViewAction?</personpresentable,imagepresentable></p>
<pre><code>init(model:PersonModel,tapHandle: TapImageViewAction?) {
    self.telPerson = model
    self.nameTelText = model.fullName + &quot;  &quot; + model.telPhone
    self.showImage = UIImage(named: model.avatarImageUrl!) // 暂时这样,按道理是加载url,否则没必要写到viewmodel中
    self.tapHandle = tapHandle
}
</code></pre><p>}<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> + `fullName`直接写成计算属性比较方便,当然你也可以在viewmodel中拼接  </span><br><span class="line"> + 保留一个model属性`telPerson`,因为有些赋值你不需要进行加工处理,比如年龄/身高  </span><br><span class="line"> + 虽然在`PersonPresentAble`中`nameTelText`是<span class="keyword">get</span>只读的,但是实现起来仍能可写.参见`If a protocol requires a <span class="keyword">property</span> <span class="keyword">to</span> be gettable <span class="keyword">and</span> settable, <span class="keyword">that</span> <span class="keyword">property</span> requirement cannot be fulfilled <span class="keyword">by</span> a <span class="type">constant</span> stored <span class="keyword">property</span> <span class="keyword">or</span> a <span class="command">read</span>-only computed <span class="keyword">property</span>. If <span class="keyword">the</span> protocol only requires a <span class="keyword">property</span> <span class="keyword">to</span> be gettable, <span class="keyword">the</span> requirement can be satisfied <span class="keyword">by</span> any kind <span class="keyword">of</span> <span class="keyword">property</span>, <span class="keyword">and</span> <span class="keyword">it</span> <span class="keyword">is</span> valid <span class="keyword">for</span> <span class="keyword">the</span> <span class="keyword">property</span> <span class="keyword">to</span> be also settable <span class="keyword">if</span> this <span class="keyword">is</span> useful <span class="keyword">for</span> your own code.`  </span><br><span class="line">  </span><br><span class="line">`View层和ViewController层`</span><br></pre></td></tr></table></figure></p>
<p>class ContactTableViewCell: UITableViewCell {<br>    @IBOutlet weak var telTextLabel: UILabel!<br>    @IBOutlet weak var avatarImageView: UIImageView!</p>
<pre><code>var tapHandle: TapImageViewAction?

override func awakeFromNib() {
    super.awakeFromNib()
    let tapGesture = UITapGestureRecognizer(target: self, action: &quot;tapAction&quot;)
    avatarImageView.addGestureRecognizer(tapGesture)
}

func configureDataWithViewModel(viewModel: TelPersonViewModelAble) {
    telTextLabel.text = viewModel.nameTelText
    avatarImageView.image = viewModel.showImage
    tapHandle = viewModel.tapHandle
}

func tapAction() {
    if let block = tapHandle {
        block()
    }
}
</code></pre><p>}</p>
<p>// VC<br>override func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell {<br>    let cell = tableView.dequeueReusableCellWithIdentifier(“hehe”, forIndexPath: indexPath) as! ContactTableViewCell<br>    let testModel = PersonModel(firstName: “明涛”, lastName: “胡”, telPhone: “15279107716”, avatarImageUrl: “麒麟星.jpg”)<br>    let testViewModel = TelPersonViewModel(model: testModel) {<br>        print(“我点击了头像”)<br>    }<br>    cell.configureDataWithViewModel(testViewModel)<br>    return cell<br>}<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> + 通过合成协议<span class="escape">`t</span>ypealias TelPersonViewModelAble = protocol&lt;PersonPresentAble,ImagePresentAble&gt;<span class="escape">`来</span>定义viewmodel的类型,代码复用性高  </span><br><span class="line"><span class="label"> + 在objc中,viewmodel的类型常常容易被定死,存在共同属性的时候又走上了继承的老路了...比如:</span>  </span><br><span class="line"><span class="label">![](http:</span>//<span class="number">7</span>qn7zn.com1.z0.glb.clouddn.com/protocolppt.png)  </span><br><span class="line"><span class="label">这时只需要另定义个protocol,无须写父类弄继承,依旧那句话,让写功能跟搭积木一样:</span></span><br></pre></td></tr></table></figure></p>
<p>protocol CompanyPresentAble {<br>    var positionText: String {get}<br>}</p>
<p>typealias InvestPersonViewModelAble = protocol<personpresentable,imagepresentable,companypresentable><br>…剩下的,你懂怎么写的^_^<br>```  </personpresentable,imagepresentable,companypresentable></p>
<blockquote>
<p><strong>参考资料:</strong><br><a href="http://swift.gg/2015/12/15/mixins-over-inheritance/" target="_blank" rel="external">Mixins 比继承更好</a><br><a href="https://github.com/atConf/atswift-2016-resources/blob/master/keynotes/%E6%9D%8E%E6%B4%81%E4%BF%A1_Pop%20in%20Swift.pdf" target="_blank" rel="external">Swift中的协议编程</a><br><a href="http://www.raywenderlich.com/109156/introducing-protocol-oriented-programming-in-swift-2" target="_blank" rel="external">Introducing Protocol-Oriented Programming in Swift 2</a><br><a href="https://www.natashatherobot.com/updated-protocol-oriented-mvvm-in-swift-2-0/" target="_blank" rel="external">Updated: Protocol-Oriented MVVM in Swift 2.0</a><br><a href="http://matthijshollemans.com/2015/07/22/mixins-and-traits-in-swift-2/" target="_blank" rel="external">Mixins and Traits in Swift 2.0</a><br><a href="http://casatwy.com/iosying-yong-jia-gou-tan-viewceng-de-zu-zhi-he-diao-yong-fang-an.html" target="_blank" rel="external">iOS应用架构谈 view层的组织和调用方案</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u5F15"><a href="#u5F15" class="headerlink" title="引"></a><font color="IndianRed">引</font></h2><p>记得从大学学编程开始,对于软件编程听的最多的就是<code>面向对象编程(Object Oriented Programming，OOP)</code>了,它的三大特征:封装,继承,多态.而Swift倡导的<code>面向协议编程(Protocol-oriented programming,POP)</code>是OOP的一个范例,我理解为”封装+协议*结构体+扩展”(Swift2.0开始,你可以扩展一个<code>protocol</code>)  </p>
<p><a href="https://developer.apple.com/videos/play/wwdc2015-408/">WWDC:Protocol-Oriented Programming in Swift</a>开头<code>Classess Are Awesome</code>,指出OOP中的<code>Classes</code>提供了:数据的封装、访问控制、抽象化、命名空间等,但这些都是<code>Classes</code>才特有的属性吗?事实上,这些都是<code>类型(Type)</code>的所有属性,<code>Classes</code>只是<code>Type</code>的一种实现方法,在Swift中<code>I can do all that with structs and enums</code>(Swift的标准库组成:55个Protocols和102个Structs),这一点可以理解为封装性.而继承和多态,是<code>struct</code>和<code>enum</code>不具备的,它则是通过遵守<code>protocol</code>来实现.  </p>
<p>但,这些是为了说明让我们放弃<code>OOP</code>吗?这是不可能的….想想<code>UIKit</code>….记得刚开始用Swift写项目时,总是告诫自己,不能只是机械的把<code>objc 翻译成 swift</code>.<font color="IndianRed">实际开发项目中,<code>ViewControl</code>和<code>View</code>基本都是使用系统的框架,通过继承来实现,无论如何的自定义,都是要围绕苹果的那一套来,OC与swift在这一块保持一致;但在<code>model</code>和<code>handle/viewModel/manager</code>这一块,更多的通过POP实现,后面会通过一个例子来说明.</font>(PS:在oc中,我们体会的是OOP/FRP(参考一下<code>RAC</code>),那Swift就是OOP/FRP(参考一下<code>RxSwift</code>)/POP;在oc中对于Protocols的理解更多的是<code>UIAppplicationDelegate,UITableViewDelegete,NSCopying,UITextFieldDelegate....</code>,而Swift中Protocols则被赋予了更多的功能和意义:”可定义属性,可组合,可继承,可扩展,支持泛型,支持类/结构体/枚举”).在<a href="http://www.cocoachina.com/swift/20150729/12824.html">Swift面向协议编程初探</a>中,bz总结的一句话,非常nice:<br><code>面向对象编程和面向协议编程最明显的区别在于程序设计过程中对数据类型的抽取(抽象)上，面向对象编程使用类和继承的手段，数据类型是引用类型</code><br><code>面向协议编程使用的是遵守协议的手段，数据类型是值类型（Swift中的结构体或枚举)</code><br>PS:<code>值类型</code>和<code>引用类型</code>的区别这里不作详叙,可参考<a href="http://swift.gg/2015/08/14/friday-qa-2015-07-17-when-to-use-swift-structs-and-classes/">Swift：什么时候使用结构体和类</a>  </p>
<h2 id="u8BA8_u538C_u7684_u201D_u4E0A_u5E1D_u201D_28Inheritence_29"><a href="#u8BA8_u538C_u7684_u201D_u4E0A_u5E1D_u201D_28Inheritence_29" class="headerlink" title="讨厌的”上帝”(Inheritence)"></a><font color="IndianRed">讨厌的”上帝”(Inheritence)</font></h2><p><code>继承</code>带给我们最大的问题,可能就是常常会构造出所谓的<code>God类/super类</code>,带来的坏处也随之可见:</p>
<ul>
<li>一层一层一层的传递下去,它的任何行为都会影响它的所有小弟;  </li>
<li>有的小弟继承了无用的属性和方法;  </li>
<li>不方便扩展,差别不大的同类上帝,直接拷贝一遍代码?<br>特别喜欢<a href="http://casatwy.com/tiao-chu-mian-xiang-dui-xiang-si-xiang-yi-ji-cheng.html">田伟宇博客:跳出面向对象思想(一) 继承</a>中提到关于<code>继承</code>的要点之一:父类的所有变化，都需要在子类中体现，也就是说此时耦合已经成为需求.(他的文章非常nice,在架构这一块的写的系列文章值得深读)so,LZ的观点也是<code>万不得已不要用继承,优先考虑组合</code>!<br>注:在objc中,更多的是用<code>组合(Composition)</code>,在Swift中则是<code>协议&gt;组合&gt;继承</code>.后面会举例说明.<br>再注:全文的Demo在<a href="https://github.com/ConanMTHu/SwiftProtocol">这里</a><br>我们通过两张图对比一下:引用自<a href="http://www.kancloud.cn/luofei614/programmer_talk_life/107498">程序员聊人生</a>]]>
    
    </summary>
    
      <category term="protocol MVVM Mixins Traits composition" scheme="http://hmttommy.com/tags/protocol-MVVM-Mixins-Traits-composition/"/>
    
      <category term="Swift" scheme="http://hmttommy.com/categories/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[UIScrollView展示图片的三次升级]]></title>
    <link href="http://hmttommy.com/2015/12/21/UIScrollViewAndUIImageView/"/>
    <id>http://hmttommy.com/2015/12/21/UIScrollViewAndUIImageView/</id>
    <published>2015-12-21T10:50:45.000Z</published>
    <updated>2016-01-21T03:57:15.000Z</updated>
    <content type="html"><![CDATA[<p>特殊情况来需求了,还在填坑中!…….</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>特殊情况来需求了,还在填坑中!…….</p>
]]>
    </summary>
    
      <category term="imageView 性能优化" scheme="http://hmttommy.com/tags/imageView-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="Swift" scheme="http://hmttommy.com/categories/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift Moya]]></title>
    <link href="http://hmttommy.com/2015/12/15/Moya/"/>
    <id>http://hmttommy.com/2015/12/15/Moya/</id>
    <published>2015-12-15T06:42:49.000Z</published>
    <updated>2015-12-21T06:50:45.000Z</updated>
    <content type="html"><![CDATA[<p>网络层这一块用<a href="https://github.com/Alamofire/Alamofire" target="_blank" rel="external">Alamofire</a>,如同于在oc中用<a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="external">AFNetworking</a>.但是,如果你直接使用的话,会使得各种网络请求操作分布很凌乱,所以我选择了巧神封装的<a href="https://github.com/yuantiku/YTKNetwork" target="_blank" rel="external">YTKNetwork</a>,很好用,有兴趣的可以看一下.当然你也可以自己组织封装.<br>这段代码就是LZ项目中的网络请求:<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">NSDictionary *parameterDic = @&#123;kPageSizeKey:</span>@<span class="string">"10"</span>,kCurPageKey:@<span class="string">"1"</span>,kLastIDKey:@<span class="string">"0"</span>&#125;<span class="comment">;</span></span><br><span class="line"><span class="label">[[WCRequestDataManager sharedRequestDataManager] requestDataForNetWorkWithDataHandleType:</span>WCProductListDataHandleType</span><br><span class="line"><span class="label">    parameterDic:</span>parameterDic</span><br><span class="line"><span class="label">    completed:</span>^(WCProductResultModel *resultModel) &#123;&#125;</span><br><span class="line"><span class="label">    failure:</span>^(NSString *msg) &#123;&#125;</span><br><span class="line">]<span class="comment">;</span></span><br><span class="line"><span class="escape">``</span><span class="escape">` </span> </span><br><span class="line"> + <span class="escape">`p</span>arameterDic<span class="escape">`就</span>是请求所需的参数,如果没有直接传入<span class="escape">`n</span>il<span class="escape">` </span> </span><br><span class="line"> + <span class="escape">`W</span>CProductListDataHandleType<span class="escape">`是</span>枚举类型,你可以理解为它对应了<span class="escape">`产</span>品列表<span class="escape">`网</span>络请求的<span class="escape">`m</span>ethod(GET/POST)<span class="escape">`,</span><span class="escape">`U</span>RL<span class="escape">`等</span>等  </span><br><span class="line"> + <span class="escape">`c</span>ompleted<span class="escape">`和</span><span class="escape">`f</span>ailure<span class="escape">`2</span>个block分别对应请求<span class="escape">`成</span>功<span class="escape">`和</span><span class="escape">`失</span>败<span class="escape">`两</span>种情况,并返回页面需要的model和失败的信息  </span><br><span class="line"> + 数据解析直接在对应的<span class="escape">`R</span>equestHandle<span class="escape">`中</span>,保证返回对应的model-&gt;<span class="escape">`W</span>CProductResultModel<span class="escape">` </span> </span><br><span class="line">  </span><br><span class="line"><span class="label">那么Swift中推荐一下[Moya](https:</span>//github.com/Moya/Moya),这是一个基于<span class="escape">`A</span>lamofire<span class="escape">`的</span>更高层网络请求封装抽象层.  </span><br><span class="line"><span class="label">**整个Demo可以在这里下载到:[MoyaTest](https:</span>//github.com/ConanMTHu/MoyaTest)**  </span><br><span class="line"><span class="label">可以对比一下直接用`Alamofire`和用`Moya`请求样式:</span></span><br></pre></td></tr></table></figure></p>
<pre><code>Alamofire.request(.GET, kRequestServerKey + &quot;services/creditor/product/list/page/2/0/0&quot;).responseJSON {
    response in
    if let value = response.result.value {
        let result = Mapper&lt;CommonInfo&gt;().map(value)
        let dataList = Mapper&lt;ProductModel&gt;().mapArray(result?.data?[&quot;result&quot;])
        print(&quot;Alamofire = \(dataList?[0].productDesc)&quot;) // Alamofire = Optional(&quot;gfhgfgfhgshgdsfdshgfshfgh&quot;)
    }
}

MoyaTest.sharedInstance.requestDataWithTarget(.productList(pageSize: 2, curpage: 0, lastID: 0), type: ProductModel.self, successClosure: { result in
        let dataList = Mapper&lt;ProductModel&gt;().mapArray(result[&quot;result&quot;])
        print(&quot;Moya = \(dataList?[0].productDesc)&quot;) // Moya = Optional(&quot;gfhgfgfhgshgdsfdshgfshfgh&quot;)
    }) { errorMsg in
        print(errorMsg)
}
</code></pre><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">可见,第二种隐藏了<span class="escape">`u</span>rl<span class="escape">`,</span><span class="escape">`m</span>ethod<span class="escape">`,</span><span class="escape">`j</span>son解析<span class="escape">`等</span>参数/操作,抽象出了一层通用的请求方法.(按理说<span class="escape">`M</span>apper&lt;ProductModel&gt;().mapArray(result[<span class="string">"result"</span>])<span class="escape">`不</span>应该出现在回调的闭包中,返回的就应该是<span class="escape">`p</span>roductList<span class="escape">`请</span>求对应的model,否则<span class="escape">`t</span>ype<span class="escape">`这</span>个参数就没有意义了,这个梗会在下面说到)  </span><br><span class="line">  </span><br><span class="line">&lt;!--more--&gt;  </span><br><span class="line"><span class="label">看一下文档说明:</span>  </span><br><span class="line"><span class="label">![](http:</span>//<span class="number">7</span>qn7zn.com1.z0.glb.clouddn.com/屏幕快照<span class="var_expand">%202015-12-16%</span><span class="number">2020.33</span>.<span class="number">28</span>.png)  </span><br><span class="line"></span><br><span class="line">**&lt;font size=<span class="string">"5"</span> color=<span class="string">"IndianRed"</span>&gt;[Targets](https://github.com/Moya/Moya/blob/master/docs/Targets.md)&lt;/font&gt;**  </span><br><span class="line">---  </span><br><span class="line"><span class="label"> 使用`Moya`的第一步就是定义一个`Target`:</span>通常是指一些符合<span class="escape">`T</span>argetType protocol<span class="escape">`的</span><span class="escape">`e</span>num<span class="escape">`.</span>然,你请求的其余部分都只根据这个<span class="escape">`T</span>arget<span class="escape">`而</span>来.这个枚举用来定义你的<span class="escape">`网</span>络请求API<span class="escape">`的</span>行为<span class="escape">`a</span>ction<span class="escape">`.</span></span><br></pre></td></tr></table></figure>
<p> public enum RequestApi {<br>    //  UserApi<br>    case login(loginName: String, password: String)<br>    case register //(userMobile: String, password: String, inviteCode: String, verifyCode: String)<br>    //case accountInfo</p>
<pre><code>//  ProductApi
case productList(pageSize: Int, curpage: Int, lastID: Int)
</code></pre><p>//    case productDetail(id: Int)<br>}<br> <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">+ </span>强烈推荐[<span class="link_label">Swift 中枚举高级用法及实践</span>](<span class="link_url">http://swift.gg/2015/11/20/advanced-practical-enum-examples/</span>)这篇文章,涵盖了枚举几乎所有的知识点.<span class="code">`enum`</span>在Swift中的作用,简直不要太牛!  </span><br><span class="line"><span class="bullet">+ </span>再推荐一个[<span class="link_label">用模式匹配解析 URL</span>](<span class="link_url">http://swift.gg/2015/09/15/urls-and-pattern-matching/#qrcode</span>),通过<span class="code">`关联值(Associated Value)`</span>来定义请求所需的参数(loginName和password也可以省略掉,但为了直观的说明,还是保留一下)</span><br></pre></td></tr></table></figure></p>
<p> extension RequestApi: TargetType {<br>    public var baseURL: NSURL {<br>        return NSURL(string: “<a href="http://apptest.wecube.com:8080/taojinjia/&quot;)!" target="_blank" rel="external">http://apptest.wecube.com:8080/taojinjia/&quot;)!</a><br>    }</p>
<pre><code>public var path: String {
    switch self {
        case .login(_,_):
            return &quot;services/crane/sso/login/doLogin&quot;
        case .register:
            return &quot;services/crane/sso/login/register&quot;
        case let .productList(pageSize, curpage, lastID):
            return &quot;services/creditor/product/list/page/&quot;+String(pageSize)+&quot;/&quot;+String(curpage)+&quot;/&quot;+String(lastID)
    }
}

public var method: Moya.Method {
    switch self {
        case .login(_,_), .register:
            return .POST
        case .productList(_,_,_):
            return .GET
    }
}

public var parameters: [String: AnyObject]? {
    switch self {
        case let .login(loginName, password):
            return [&quot;loginName&quot;: loginName, &quot;userPassword&quot;: password]
        default :
            return nil
    }
}

//  单元测试用
public var sampleData: NSData {
    return &quot;{}&quot;.dataUsingEncoding(NSUTF8StringEncoding)!
}
</code></pre><p>}<br> <figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">定义的<span class="class"><span class="keyword">enum</span>实现`<span class="title">TargetType</span>`协议,完成一系列初始化设置:  </span></span><br><span class="line"> + &lt;font color=<span class="string">"IndianRed"</span>&gt;<span class="string">`baseURL`</span>&lt;<span class="regexp">/font&gt;:统一设置服务器地址,测试切换非常的方便,`YTKNetwork`中也是这样配置的.  </span><br><span class="line"> + &lt;font color="IndianRed"&gt;`path`&lt;/font</span>&gt;:每个请求需求对应的各自的请求路径</span><br></pre></td></tr></table></figure></p>
<pre><code>参见源码,最终的url就是由baseURL和path拼接而来
public final class func DefaultEndpointMapping(target: Target) -&gt; Endpoint&lt;Target&gt; {
    let url = target.baseURL.URLByAppendingPathComponent(target.path).absoluteString
    return Endpoint(URL: url, sampleResponseClosure: {.NetworkResponse(200, target.sampleData)}, method: target.method, parameters: target.parameters)
}
</code></pre> <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> + &lt;<span class="attribute">font</span> <span class="attribute">color</span>=<span class="string">"IndianRed"</span>&gt;`method`&lt;/<span class="attribute">font</span>&gt;:不解释...请求方式  </span><br><span class="line"> + &lt;<span class="attribute">font</span> <span class="attribute">color</span>=<span class="string">"IndianRed"</span>&gt;`parameters`&lt;/<span class="attribute">font</span>&gt;:需要的参数  </span><br><span class="line"> + &lt;<span class="attribute">font</span> <span class="attribute">color</span>=<span class="string">"IndianRed"</span>&gt;`sampleData`&lt;/<span class="attribute">font</span>&gt;:方便于单元测试...暂时忽略  </span><br><span class="line">  </span><br><span class="line">**&lt;<span class="attribute">font</span> size=<span class="string">"5"</span> <span class="attribute">color</span>=<span class="string">"IndianRed"</span>&gt;[Providers](https:<span class="comment">//github.com/Moya/Moya/blob/master/docs/Providers.md)和[Endpoints](https://github.com/Moya/Moya/blob/master/docs/Endpoints.md)&lt;/font&gt;**  </span></span><br><span class="line">---  </span><br><span class="line">`provider`和`endpoints`是紧密相关的,放在一起讲更好点(名字都怪怪的,果然国外开发者取名都是讲究哇)</span><br></pre></td></tr></table></figure>
<p>let requestProvider = RxMoyaProvider<requestapi>()<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">最终的请求发起对象就是<span class="escape">`r</span>equestProvider<span class="escape">`,</span><span class="escape">`R</span>xMoyaProvider<span class="escape">`是</span><span class="escape">`M</span>oyaProvider<span class="escape">`的</span>子类,你需要在podfile中导入<span class="escape">`M</span>oya/RxSwift<span class="escape">`,</span>当然你也可以直接用<span class="escape">`M</span>oyaProvider<span class="escape">`来</span>完成初始化,<span class="escape">`R</span>xSwift<span class="escape">`目</span>前只是简单的了解了一下,具体用法这里暂时忽略,不影响请求的完成.  </span><br><span class="line"><span class="label">你可能发现,这跟`endpoints`并没什么关系,但是,看下源码:</span></span><br></pre></td></tr></table></figure></requestapi></p>
<pre><code>/// Initializes a provider.
public init(endpointClosure: EndpointClosure = MoyaProvider.DefaultEndpointMapping,
    requestClosure: RequestClosure = MoyaProvider.DefaultRequestMapping,
    stubClosure: StubClosure = MoyaProvider.NeverStub,
    manager: Manager = Alamofire.Manager.sharedInstance,
    plugins: [PluginType] = []) {

        self.endpointClosure = endpointClosure
        self.requestClosure = requestClosure
        self.stubClosure = stubClosure
        self.manager = manager
        self.plugins = plugins
}

/// Mark: Defaults
</code></pre><p>public extension MoyaProvider {</p>
<pre><code>// These functions are default mappings to endpoings and requests.

public final class func DefaultEndpointMapping(target: Target) -&gt; Endpoint&lt;Target&gt; {
    let url = target.baseURL.URLByAppendingPathComponent(target.path).absoluteString
    return Endpoint(URL: url, sampleResponseClosure: {.NetworkResponse(200, target.sampleData)}, method: target.method, parameters: target.parameters)
}

public final class func DefaultRequestMapping(endpoint: Endpoint&lt;Target&gt;, closure: NSURLRequest -&gt; Void) {
    return closure(endpoint.urlRequest)
}
</code></pre><p>}<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> + <span class="escape">`i</span>nit<span class="escape">`的</span><span class="number">4</span>个参数都给了默认参数,且默认的endpoint<span class="escape">`D</span>efaultEndpointMapping<span class="escape">`如</span>同它的名字一样,<span class="string">"终结点"</span>匹配了网络请求要的因素.  </span><br><span class="line"> + 如果你的请求需要添加请求头,你也能够通过<span class="escape">`e</span>ndpointByAddingHTTPHeaderFields<span class="escape">`方</span>法来实现.  </span><br><span class="line"> + <span class="escape">`T</span>arget<span class="escape">`贯</span>穿了全局,在endpoint的配置中,也可以通过刷选不同的枚举值来设置不同情况.  </span><br><span class="line"> + 还有一些高级用法就自己去研究文档,LZ的英文实在是渣的可怕...  </span><br><span class="line">在上面的栗子中,选择了默认的初始化方法.  </span><br><span class="line">  </span><br><span class="line">**&lt;font size=<span class="string">"5"</span> color=<span class="string">"IndianRed"</span>&gt;Request&lt;/font&gt;**  </span><br><span class="line">---</span><br></pre></td></tr></table></figure></p>
<p>import Foundation<br>import Moya<br>import RxSwift<br>import ObjectMapper<br>import SwiftyJSON</p>
<p>typealias SuccessClosure = (result: AnyObject) -&gt; Void<br>//typealias SuccessClosure = (result: Mappable) -&gt; Void<br>typealias FailClosure = (errorMsg: String?) -&gt; Void</p>
<p>enum RequestCode: String {<br>    case failError = “0”<br>    case success = “1”<br>}</p>
<p>class MoyaTest {<br>    static let sharedInstance = MoyaTest()<br>    private init(){}</p>
<pre><code>let requestProvider = RxMoyaProvider&lt;RequestApi&gt;()

func requestDataWithTarget&lt;T: Mappable&gt;(target: RequestApi, type: T.Type , successClosure: SuccessClosure, failClosure: FailClosure) {
    let _ = requestProvider.request(target).subscribe { (event) -&gt; Void in
        switch event {
        case .Next(let response):
            let info = Mapper&lt;CommonInfo&gt;().map(JSON(data: response.data,options: .AllowFragments).object)
            guard info?.code == RequestCode.success.rawValue else {
                failClosure(errorMsg: info?.msg)
                return
            }
            guard let data = info?.data else {
                failClosure(errorMsg: &quot;数据为空&quot;)
                return
            }
            successClosure(result: data)
        case .Error(let error):
            print(&quot;网络请求失败...\(error)&quot;)
        default:
            break
        }
    }
}
</code></pre><p>}<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">最后的请求方法封装,如上面的栗子:  </span><br><span class="line"> + json的解析我用的<span class="code">`SwiftyJson`</span>和<span class="code">`ObjectMapper`</span>.<span class="code">`SwiftyJson`</span>主要是用来把data转为object(这里如果调用<span class="code">`JSON(response.data)`</span>会无法解析,要显式的加上参数<span class="code">`options`</span>,但其实<span class="code">`JSON(xxx)`</span>内部是默认实现了的,实在不明白为什么会解析失败...参数的解释参见[<span class="link_label">hit me</span>](<span class="link_url">http://www.cocoachina.com/bbs/read.php?tid=110907</span>)和[<span class="link_label">hit me too</span>](<span class="link_url">http://stackoverflow.com/questions/16961025/nsjsonserialization-nsjsonreadingallowfragments-reading</span>)),后面的转model用的就是<span class="code">`ObjectMapper`</span>.<span class="xml"><span class="tag">&lt;<span class="title">font</span> <span class="attribute">color</span>=<span class="value">"red"</span>&gt;</span></span>这里补上前面提到的:为什么没能够做到返回直接是请求数据对应的model,而多做了一步<span class="code">`let dataList = Mapper&lt;ProductModel&gt;().mapArray(result["result"])`</span><span class="xml"><span class="tag">&lt;/<span class="title">font</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p> // 服务器给的数据格式统一为<br>{<br>    “code” = “”,<br>    “data” =  {} 或 ({}),<br>    “msg” = “”<br>}<br> <figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`data`对应的就是请求url返回的`model`或`[model]`,那么就是不是调用`successClosure(<span class="literal">result</span>: data)`了,而是</span><br></pre></td></tr></table></figure></p>
<pre><code> //typealias SuccessClosure = (result: Mappable) -&gt; Void
 let model = Mapper&lt;T&gt;().map(data)
successClosure(result: model)
</code></pre><p> <code>``  
 有的接口</code>data<code>对应的是包含了多个dic的数组,感觉解决方法就是再单独开一个数组的请求方法,调用</code>mapArray<code>,这里就不多加描述了,反正都一样的流程.  
 而</code>productList<code>的url返回的</code>data<code>里面还包了一层</code>result<code>和</code>pageVO`,so…这就是一个特殊情况^_^!  </p>
<ul>
<li><code>RxSwift</code>…学习中  </li>
</ul>
<p>ok!差不多<code>Moya</code>的基本使用就是这样啦,感觉还是非常方便实用的.  </p>
<blockquote>
<p><strong>参考资料</strong><br><a href="http://blog.callmewhy.com/2015/11/01/moya-rxswift-argo-lets-go/" target="_blank" rel="external">通过 Moya+RxSwift+Argo 完成网络请求</a><br><a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="external">RxSwift</a>  </p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>网络层这一块用<a href="https://github.com/Alamofire/Alamofire" target="_blank" rel="external">Alamofire</a>,如同于在oc中用<a href="https://github.com/]]>
    </summary>
    
      <category term="network request" scheme="http://hmttommy.com/tags/network-request/"/>
    
      <category term="Swift" scheme="http://hmttommy.com/categories/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift Closure与AnyObject在Extension中的转换]]></title>
    <link href="http://hmttommy.com/2015/12/11/AddCategoryProperty/"/>
    <id>http://hmttommy.com/2015/12/11/AddCategoryProperty/</id>
    <published>2015-12-11T10:10:14.000Z</published>
    <updated>2015-12-11T12:25:59.000Z</updated>
    <content type="html"><![CDATA[<p>LZ个人很喜欢用<code>blcok</code>,<code>RAC</code>中也是各种的block调用,比如对UIButton的点击事件<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="atom">xxxButton</span>.<span class="atom">rac_command</span> = [[<span class="name">RACCommand</span> <span class="atom">alloc</span>] <span class="atom">initWithSignalBlock</span>:^<span class="name">RACSignal</span> *(<span class="name">UIButton</span> *<span class="atom">button</span>) &#123;</span><br><span class="line">                // 事件处理</span><br><span class="line">                <span class="atom">return</span> [<span class="name">RACSignal</span> <span class="atom">empty</span>];</span><br><span class="line">            &#125;];</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`  </span><br><span class="line">block的形式能够让代码更加的紧凑,让事件的响应处理紧跟属性对象的设置.  </span><br><span class="line"></span><br><span class="line">不用RAC的话,我们通常采取`</span><span class="name">Category</span><span class="string">`的方式来实现:</span></span><br></pre></td></tr></table></figure></p>
<p>#import <objc runtime.h=""></objc></p>
<p>//唯一静态变量key<br>static const char blockKey;</p>
<p>@implementation UIButton (Block)</p>
<ul>
<li><p>(void)handleControlEvent:(UIControlEvents)event withBlock:(ActionBlock)block {<br>  objc_setAssociatedObject(self, &amp;blockKey, block, OBJC_ASSOCIATION_COPY_NONATOMIC);<br>  [self addTarget:self action:@selector(callActionBlock:) forControlEvents:event];<br>}</p>
</li>
<li><p>(void)callActionBlock:(id)sender {<br>  ActionBlock block = (ActionBlock)objc_getAssociatedObject(self, &amp;blockKey);<br>  if (block) {</p>
<pre><code>block();
</code></pre><p>  }<br>}</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**因为`Category`中并不能添加实例属性,所以要通过`runtime`的关联性来实现.**</span>  </span><br><span class="line">  </span><br><span class="line">同理,在Swift中也是一样的,<span class="code">`Extension`</span>中不能添加存储属性(但是可以添加计算属性),也要通过运行时的<span class="code">`get和set Associated Object`</span>来实现.  </span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">font</span> <span class="attribute">color</span>=<span class="value">"red"</span>&gt;</span></span>不过,在Swift中,<span class="code">`Closure(闭包)`</span>并不属于<span class="code">`AnyObject`</span>,不像oc中block可以作为id对象!因此,需要做一个相互转换<span class="xml"><span class="tag">&lt;/<span class="title">font</span>&gt;</span></span>.转换的方法在万能的<span class="code">`stackoverflow`</span>中找到了,[<span class="link_label">点我</span>](<span class="link_url">http://stackoverflow.com/questions/24586293/cast-closures-blocks</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>private var closureKey: Void?<br>typealias ActionClosure = @convention(block) () -&gt; ()<br>extension UIButton {<br>    func handleControlEvent(event: UIControlEvents,closure: ActionClosure) {<br>        let dealObject: AnyObject = unsafeBitCast(closure, AnyObject.self)<br>        objc_setAssociatedObject(self, &amp;closureKey, dealObject, .OBJC_ASSOCIATION_COPY_NONATOMIC)<br>        self.addTarget(self, action: “callActionClosure:”, forControlEvents: event)<br>    }</p>
<pre><code>func callActionClosure(btn: UIButton) {
    let closureObject: AnyObject = objc_getAssociatedObject(self, &amp;closureKey)
    let closure = unsafeBitCast(closureObject, ActionClosure.self)
    closure()
}
</code></pre><p>}<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> + 如何添加计算属性,参照喵大大的<span class="escape">`S</span>WIFTER<span class="escape">`的</span><span class="escape">`A</span>ssociated Object<span class="escape">`章</span>节.  </span><br><span class="line"> + <span class="escape">`&amp;</span>closureKey<span class="escape">`,</span>参照喵大大的<span class="escape">`S</span>WIFTER<span class="escape">`的</span><span class="escape">`U</span>nsafePointer<span class="escape">`章</span>节.  </span><br><span class="line">  </span><br><span class="line"><span class="label">如上,我们就这样的调用了:</span></span><br></pre></td></tr></table></figure></p>
<pre><code>let btn = UIButton(type: .ContactAdd)
btn.frame = CGRect(x: 100,y: 100,width: 30,height: 30)
self.view.addSubview(btn)
btn.handleControlEvent(.TouchUpInside) {
    print(&quot;hello world&quot;)
}
</code></pre><p>```</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>LZ个人很喜欢用<code>blcok</code>,<code>RAC</code>中也是各种的block调用,比如对UIButton的点击事件<br><figure class="highlight prolog"><table><tr><td class="gutte]]>
    </summary>
    
      <category term="Category closure objc_set/get" scheme="http://hmttommy.com/tags/Category-closure-objc-set-get/"/>
    
      <category term="Swift" scheme="http://hmttommy.com/categories/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SwiftyJson + ObjectMapper + Argo]]></title>
    <link href="http://hmttommy.com/2015/11/29/swiftjson/"/>
    <id>http://hmttommy.com/2015/11/29/swiftjson/</id>
    <published>2015-11-28T17:27:37.000Z</published>
    <updated>2016-01-13T07:11:30.000Z</updated>
    <content type="html"><![CDATA[<p>学习Swift一段时间后,接下来的方法就是找个项目来练手了,于是LZ就决定空余时间用Swift重写目前的整个项目.鉴于UI需求变幻莫测,1.0后没多久又来的2.0…还是先从稳定的<code>数据层</code>和<code>网络层</code>着手.^_^<br><code>json &lt;-&gt; model</code>这一块选了3个第三方库,如标题,分析一下它们各自的用法和总结.    </p>
<h2 id="SwiftyJson"><a href="#SwiftyJson" class="headerlink" title="SwiftyJson"></a><font color="IndianRed">SwiftyJson</font></h2><p><a href="https://github.com/SwiftyJSON/SwiftyJSON" target="_blank" rel="external">SwiftyJson</a>算是最早听过的Swift第三方库了,不过一直都没用过..囧..用起来还是很简单的:<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">        Alamofire.request(.GET, kRequestServerKey + <span class="string">"services/wecube/user/msg/shareItem/INVEST_SHARE_ITEM"</span>).responseJSON &#123;</span><br><span class="line">            response in</span><br><span class="line">            <span class="keyword">if</span> let value = response.result.value &#123;</span><br><span class="line">                let json = JSON(value)</span><br><span class="line">                print(json)</span><br><span class="line">                print(json[<span class="string">"data"</span>].dictionaryObject)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="escape">``</span><span class="escape">` </span> </span><br><span class="line"><span class="label">![](http:</span>//<span class="number">7</span>qn7zn.com1.z0.glb.clouddn.com/jsonmodel.png)  </span><br><span class="line"><span class="label">具体的用法可以参加它的github地址,列举的很详细了,来谈谈几点:</span>  </span><br><span class="line"> + 我们oc项目中用<span class="escape">`M</span>JExtension<span class="escape">`或</span>者<span class="escape">`Y</span>YModel<span class="escape">`可</span>以做到定义好model属性,自动完成赋值.<span class="escape">`S</span>wiftyJson<span class="escape">`没</span>有提供跟model的映射,而是需要我们手动去赋值,比如例子中的<span class="escape">`j</span>son[<span class="string">"data"</span>]<span class="escape">`,</span>如果层级有<span class="number">3</span>层以后,就会这样<span class="escape">`j</span>son[xxx][xxx][xxx][<span class="string">"name"</span>]<span class="escape">`,</span>其实取值貌似也就是这样的...只是如果我不小心写错了key,这应该是我不选择它的主要原因.      </span><br><span class="line"> + 由于Swift是一种严格的类型安全语言.虽然这样有利于我们减少错误,但是对于json这种天生就是隐式类型的数据结构,就很蛋疼了.<span class="escape">`S</span>wiftyJson<span class="escape">`很</span>好的解决了,json解析过程中容易出现的<span class="escape">`i</span>f-let<span class="escape">`*</span>*金字塔**(如下)或可选用链.</span><br></pre></td></tr></table></figure></p>
<p> if let statusesArray = try? NSJSONSerialization.JSONObjectWithData(data, options: .AllowFragments) as? [[String: AnyObject]],<br>    let user = statusesArray[0][“user”] as? [String: AnyObject] {<br>      let username = user[“name”] as? String {<br>        let xxx = xxxx[“xxxx”] as? String {<br>        //   好恶心啊……..<br>       }<br>    }<br>   }<br>}<br> <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">+ </span>针对第二点,为什么<span class="code">`SwiftyJson`</span>的解析不需要担心可选的crash?看个栗子:</span><br></pre></td></tr></table></figure></p>
<pre><code>if let imageUrl = json[&quot;data&quot;][&quot;imageUrl_test&quot;].string{
    // 调用不存在的[&quot;imageUrl_test&quot;]也不会crash,.string最终能安全的返回一个字符串或nil
}
</code></pre> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--more--&gt;</span>  </span><br><span class="line">  </span><br><span class="line">我们可以看一下源码:(就一个文件)</span><br></pre></td></tr></table></figure>
<pre><code> /// If `type` is `.Dictionary`, return json which&apos;s object is `dictionary[key]` , otherwise return null json with error.
private subscript(key key: String) -&gt; JSON {
    get {
        var r = JSON.null
        if self.type == .Dictionary {
            if let o = self.rawDictionary[key] {
                r = JSON(o)
            } else {
                r._error = NSError(domain: ErrorDomain, code: ErrorNotExist, userInfo: [NSLocalizedDescriptionKey: &quot;Dictionary[\&quot;\(key)\&quot;] does not exist&quot;])
            }
        } else {
            r._error = self._error ?? NSError(domain: ErrorDomain, code: ErrorWrongType, userInfo: [NSLocalizedDescriptionKey: &quot;Dictionary[\&quot;\(key)\&quot;] failure, It is not an dictionary&quot;])
        }
        return r
    }
    set {
        if self.type == .Dictionary &amp;&amp; newValue.error == nil {
            self.rawDictionary[key] = newValue.object
        }
    }
}
</code></pre> <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> 可见,始终都会返回一个<span class="code">`JSON`</span>类型的对象r,<span class="code">`.null`</span>其实也是<span class="code">`JSON`</span>类型,这样即使报错返回的都是跟解析时一样的<span class="code">`JSON`</span>类型,那就不用写一个个的<span class="code">`?`</span>了,也不用担心数组取值越界或者字典的key不存在等情况.直到你调用<span class="code">`.string .number .arrayObject`</span>等才会返回对应的类型或nil了.(<span class="code">`.stringValue`</span>不会返回nil,而是"",空字符串...依旧见源码)  </span><br><span class="line">  + 话说<span class="code">`SwiftyJson`</span>和LZ暂时在看的<span class="code">`Moya`</span>都对枚举<span class="code">`enum`</span>运用的很溜,很强大(感觉enum在Swift中作用很大却也复杂很多),这里推荐一篇SwiftGG的文章[<span class="link_label">Swift 中枚举高级用法及实践</span>](<span class="link_url">http://swift.gg/2015/11/20/advanced-practical-enum-examples/</span>)  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="header">## &lt;font color="IndianRed"&gt;ObjectMapper&lt;/font&gt;  </span></span><br><span class="line">[<span class="link_label">ObjectMapper</span>](<span class="link_url">https://github.com/Hearst-DD/ObjectMapper</span>)是朋友推荐的,他们之前也是用了<span class="code">`SwiftyJson`</span>,最近开始引入的.试了一下,还是很好操作的,举个栗子:  </span><br><span class="line">测试的Json数据</span><br></pre></td></tr></table></figure>
<p>data = {<br>    pageVO =     {<br>    };<br>    result =     (<br>                {<br>            activityCode = “”;<br>            activityType = 2;<br>            alreadyAmount = 1601;<br>            alreadyUserCount = 1;<br>            amountUse = “\U6d88\U8d39”;<br>            amountUseType = 1;<br>            productCode = “SZSB–2015-88”;<br>            productDesc = “\U9a8c\U8bc1\U65b0\U91d1\U9886\U901a”;<br>            productPublisher =             {<br>                age = 22;<br>                userCode = “411329<strong>**</strong>12”;<br>                userEmailApprove = 0;<br>                userId = “3489”;<br>                userMobile = “1<strong><strong>*</strong></strong>1”;<br>            };<br>        }<br>    );<br>}<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Model</span>层设计</span><br></pre></td></tr></table></figure></p>
<p>import ObjectMapper</p>
<p>class CommonInfo: Mappable {<br>    var data: Any?<br>    var code: String!<br>    var msg: String?<br>    required init?(_ map: Map) {<br>    }<br>    func mapping(map: Map) {<br>        data      &lt;-    map[“data”]<br>        code      &lt;-    map[“code”]<br>        msg       &lt;-    map[“mgs”]<br>    }<br>}</p>
<p>class ProductModel: Mappable {<br>    var activityType: Int?<br>    var amountUse: String?<br>    var productDesc: String?<br>    var productPublisher: PublisherModel!<br>    required init?(_ map: Map) {<br>    }<br>    func mapping(map: Map) {<br>        activityType            &lt;-    map[“activityType”]<br>        amountUse               &lt;-    map[“amountUse”]<br>        productDesc             &lt;-    map[“productDesc”]<br>        productPublisher        &lt;-    map[“productPublisher”]<br>    }<br>}</p>
<p>class PublisherModel: Mappable {<br>    var age: Int?<br>    var userCode: String?<br>    var userMobile: String?<br>    var userId: String!<br>    required init?(_ map: Map) {<br>    }<br>    func mapping(map: Map) {<br>        age            &lt;-    map[“age”]<br>        userCode       &lt;-    map[“userCode”]<br>        userMobile     &lt;-    map[“userMobile”]<br>        userId         &lt;-    map[“userId”]<br>    }<br>}<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">`<span class="javascript"></span>``<span class="javascript"></span><br><span class="line">        Alamofire.request(.GET, kRequestServerKey + <span class="string">"services/creditor/product/list/page/1/0/0"</span>).responseJSON &#123;</span><br><span class="line">            response <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> value = response.result.value &#123;</span><br><span class="line">                <span class="keyword">let</span> info = Mapper&lt;CommonInfo&gt;().map(value)</span><br><span class="line">                print(info?.data)</span><br><span class="line">                <span class="keyword">let</span> productList = Mapper&lt;ProductModel&gt;().mapArray(info?.data?[<span class="string">"result"</span>])</span><br><span class="line">                print(productList?[<span class="number">0</span>].productPublisher.userId) <span class="comment">// 3489</span></span><br><span class="line">                print(productList?[<span class="number">0</span>].productPublisher.userCode) <span class="comment">// 411329******12</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span>``<span class="javascript"></span>`  </span><br><span class="line"> + 首先需要实现`<span class="javascript">Mappable</span>`这个protocol,它有<span class="number">2</span>个方法`<span class="javascript">init?(_ map: <span class="built_in">Map</span>)</span>`和`<span class="javascript">func mapping(map: <span class="built_in">Map</span>)</span>`,通过操作符`<span class="javascript">&lt;-</span>`来进行字段与json的映射.  </span><br><span class="line"> + Model的设置基本都为可选?类型,当然你也可以通过和服务端的约定设置一些字段为隐式!解析,如上:项目Model的发起者字段为!,也就是一个项目肯定是存在一个对应的发起者,它一定不为空,那么它也就一定会有userId,至于code和mobile则不一定了,可能为空...这个看项目情况,当然你也可以全部设置为可选?.看了一下源码,它解析后返回的基本都是`<span class="javascript">N?</span>`可选类型.  </span><br><span class="line"> + `<span class="javascript">ObjectMapper</span>`返回的基本都是?,所以也就不可避免的出现了可选链,见`<span class="javascript">info?.data?[<span class="string">"result"</span>]</span>`,如果层级再高二级,那么就是`<span class="javascript">xxx?.xxx?.xxx?...</span>`,相比`<span class="javascript">SwiftyJson</span>`就不太好了...不过与属性的映射能够自动一一对应,我想我会用它.  </span><br><span class="line"> + 那`<span class="javascript">ObjectMapper</span>`是如何实现的呢?粗略的看了一下源码:</span><br></pre></td></tr></table></figure></p>
<pre><code> public func mapArray(JSON: AnyObject?) -&gt; [N]? {
    if let JSONArray = JSON as? [[String : AnyObject]] {
        return mapArray(JSONArray)
    }

    return nil
}

/// Maps an array of JSON dictionary to an array of Mappable objects
public func mapArray(JSONArray: [[String : AnyObject]]) -&gt; [N]? {
    // map every element in JSON array to type N
    let result = JSONArray.flatMap(map)
    return result
}
</code></pre> <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">可见,就是对于<span class="code">`map`</span>和<span class="code">`flatMap`</span>的调用(map和flapMap函数能够很轻易地将数组转换成另外一个新数组),其中<span class="code">`N`</span>就是那些实现了<span class="code">`Mappable`</span>的类型(运用了泛型嘛),这也就是你传入了一个json结构(一般为dic)的数组转换出来为你自定义model的数组,参见<span class="code">`let productList = Mapper&lt;ProductModel&gt;().mapArray(info?.data?["result"])`</span>,<span class="code">`productList`</span>就是装载了<span class="code">`ProductModel`</span>的数组.  </span><br><span class="line">PS:<span class="code">`map`</span>和<span class="code">`flatMap`</span>的知识可以多了解下,推荐[<span class="link_label">点我哇</span>](<span class="link_url">http://appventure.me/2015/11/30/reduce-all-the-things/</span>)和[<span class="link_label">SwiftGG</span>](<span class="link_url">http://swift.gg/2015/11/26/swift-map-and-flatmap/</span>)  </span><br><span class="line">其他详细用法参见github的doc,它还提供了了一个<span class="code">`AlamofireObjectMapper`</span>的Extension,专门配合<span class="code">`Alamofire`</span>用.  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="header">## &lt;font color="IndianRed"&gt;Argo&lt;/font&gt;  </span></span><br><span class="line">[<span class="link_label">Argo</span>](<span class="link_url">https://github.com/thoughtbot/Argo</span>)用起来就没有前两者舒服了(LZ能力问题),目前LZ还没试验出来...暂缓在这里,如果有那位童鞋<span class="code">`Argo`</span>用的溜的求留言.</span><br></pre></td></tr></table></figure>
<p> struct ShareInfo {<br>    let rowIdx: Int<br>    let imagePath: String?<br>    let content: String?<br>}</p>
<p>extension ShareInfo:Decodable {<br>    static func decode(json: JSON) -&gt; Decoded<shareinfo> {<br>        return curry(ShareInfo.init)<br>            &lt;^&gt; json &lt;|  “rowIdx”<br>            &lt;<em>&gt; json &lt;|?  “imagePath”<br>            &lt;</em>&gt; json &lt;|? “content”<br>    }<br>}</shareinfo></p>
<pre><code>Alamofire.request(.GET, kRequestServerKey + &quot;services/wecube/user/msg/shareItem/INVEST_SHARE_ITEM&quot;).responseJSON {
    response in
    if let value = response.result.value {
        print(&quot;value = \(value)&quot;)
        let info: ShareInfo? = decodeWithRootKey(&quot;data&quot;, value)
        print(info?.imagePath) // Optional(&quot;http://service.taojinjia.com/Tpl/H5/style/images/fenxiangtupian.png&quot;)
    }
}
</code></pre><p> ```  </p>
<ul>
<li>所有的Model必须声明为<code>struct</code>,且类型设置为<code>AnyObject</code>会报错(暂时不知道为何,只好将json格式的dic提前设定为你的Model),或者声明为<code>NSURL</code>需参照<a href="https://github.com/thoughtbot/Argo/issues/294" target="_blank" rel="external">decode for NSURL</a>  </li>
<li><code>return curry(ShareInfo.init)</code>后面的参数对应,第一个必须是<code>&lt;^&gt;</code>,<a href="https://github.com/thoughtbot/Argo/issues/278" target="_blank" rel="external">原因看这个解释</a>  </li>
<li>试验得知:所有的结构体属性,必须指定为明确的类型,比如<code>let info: Dictionary</code>必须写为<code>let info: Info</code>,其中<code>Info</code>对应的就是包含字典属性的结构体    </li>
<li>因此,使用<code>Argo</code>不能创建<code>CommonInfo</code>这个对象,因为它的<code>data</code>是不确定的,做不到统一接口<br>放几篇链接在此:<br><a href="https://robots.thoughtbot.com/functional-swift-for-dealing-with-optional-values" target="_blank" rel="external">Functional Swift for Dealing with Optional Values</a> (解释了<code>&lt;^&gt;</code>和<code>&lt;*&gt;</code>的含义)<br><a href="https://robots.thoughtbot.com/introduction-to-function-currying-in-swift" target="_blank" rel="external">Introduction to Function Currying in Swift</a><br><a href="https://robots.thoughtbot.com/parsing-embedded-json-and-arrays-in-swift" target="_blank" rel="external">Parsing Embedded JSON and Arrays in Swift</a><br><a href="/Efficient JSON in Swift with Functional Concepts and Generics">Efficient JSON in Swift with Functional Concepts and Generics</a><br><a href="http://www.cocoachina.com/ios/20140921/9703.html" target="_blank" rel="external">使用 Swift 解析 JSON</a>  </li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>学习Swift一段时间后,接下来的方法就是找个项目来练手了,于是LZ就决定空余时间用Swift重写目前的整个项目.鉴于UI需求变幻莫测,1.0后没多久又来的2.0…还是先从稳定的<code>数据层</code>和<code>网络层</code>着手.^_^<br><code]]>
    </summary>
    
      <category term="json model" scheme="http://hmttommy.com/tags/json-model/"/>
    
      <category term="Swift" scheme="http://hmttommy.com/categories/Swift/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://hmttommy.com/2015/11/28/iOS-CoreAnimation-04/"/>
    <id>http://hmttommy.com/2015/11/28/iOS-CoreAnimation-04/</id>
    <published>2015-11-28T03:41:08.000Z</published>
    <updated>2015-11-28T03:41:08.000Z</updated>
    <content type="html"><![CDATA[<p>title: iOS CoreAnimation(四)之CAPropertyAnimation<br>date: 2015-11-04 14:31:26<br>categories: CoreAnimation </p>
<h2 id="tags_3A_Basic_KeyFrame"><a href="#tags_3A_Basic_KeyFrame" class="headerlink" title="tags: Basic KeyFrame"></a>tags: Basic KeyFrame</h2><p><code>CAPropertyAnimation</code>作为属性动画的基类,并不能直接使用.通常我们操作的是它的两个子类<code>CABasicAnimation</code>和<code>CAKeyframeAnimation</code>.    </p>
<h3 id="CABasicAnimation"><a href="#CABasicAnimation" class="headerlink" title="CABasicAnimation"></a><font color="#ce1f48">CABasicAnimation</font></h3><ul>
<li>基础动画,通过属性修改进行动画参数控制,只有初始状态和结束状态。它只有3个属性:<code>fromValue</code> <code>toValue</code> <code>ByValue</code>,其他全是继承的(参考上一篇).对于它这3个属性可以参考:<a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CABasicAnimation_class/index.html#//apple_ref/doc/uid/TP40004496-CH1-SW4" target="_blank" rel="external">官方文档</a>  <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 如果fromValue和toValue不为nil,那么动画帧变化就是从<span class="built_in">from</span>到<span class="built_in">to</span></span><br><span class="line">Both fromValue <span class="operator">and</span> toValue are non-nil. Interpolates between fromValue <span class="operator">and</span> toValue.<span class="comment"></span><br><span class="line">// 如果fromValue和toValue不为nil,那么动画帧变化就是从from到from+by(可见byValue是相对值概念)</span></span><br><span class="line">fromValue <span class="operator">and</span> byValue are non-nil. Interpolates between fromValue <span class="operator">and</span> (fromValue + byValue).<span class="comment"></span><br><span class="line">// 剩下的大致相同...就不多解释了</span></span><br><span class="line">byValue <span class="operator">and</span> toValue are non-nil. Interpolates between (toValue - byValue) <span class="operator">and</span> toValue.</span><br><span class="line"></span><br><span class="line">fromValue is non-nil. Interpolates between fromValue <span class="operator">and</span> <span class="operator">the</span> current presentation <span class="built_in">value</span> <span class="operator">of</span> <span class="operator">the</span> property.</span><br><span class="line"></span><br><span class="line">toValue is non-nil. Interpolates between <span class="operator">the</span> current <span class="built_in">value</span> <span class="operator">of</span> keyPath <span class="operator">in</span> <span class="operator">the</span> target layer’s presentation layer <span class="operator">and</span> toValue.</span><br><span class="line"></span><br><span class="line">byValue is non-nil. Interpolates between <span class="operator">the</span> current <span class="built_in">value</span> <span class="operator">of</span> keyPath <span class="operator">in</span> <span class="operator">the</span> target layer’s presentation layer <span class="operator">and</span> that <span class="built_in">value</span> plus byValue.</span><br><span class="line"></span><br><span class="line">All properties are nil. Interpolates between <span class="operator">the</span> previous <span class="built_in">value</span> <span class="operator">of</span> keyPath <span class="operator">in</span> <span class="operator">the</span> target layer’s presentation layer <span class="operator">and</span> <span class="operator">the</span> current <span class="built_in">value</span> <span class="operator">of</span> keyPath <span class="operator">in</span> <span class="operator">the</span> target layer’s presentation layer.</span><br><span class="line">```  </span><br><span class="line">+ 使用`animationWithKeyPath:`方法进行实例化，并指定Layer(后面篇幅解释)的属性作为keyPath(关键路径)来注册.  </span><br><span class="line">&lt;font color=<span class="string">"red"</span>&gt;对于这个`keyPath`,[Core Animation Programming Guide](<span class="keyword">https</span>://developer.apple.com/library/prerelease/tvos/documentation/Cocoa/Conceptual/CoreAnimation_guide/Key-ValueCodingExtensions/Key-ValueCodingExtensions.html)中给出了一些常见的,你还可以写入path(xxx.fromValue = yyy.CGPath xxx.toValue = yyy.CGPath),layer的属性以及其子类的比如:strokeStart,locations(CAGradientLayer)...&lt;/font&gt;    </span><br><span class="line">&lt;!<span class="comment">--more--&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>rotation.x Set to an NSNumber object whose value is the rotation, in radians, in the x axis.<br>rotation.y Set to an NSNumber object whose value is the rotation, in radians, in the y axis.<br>rotation.z Set to an NSNumber object whose value is the rotation, in radians, in the z axis.<br>rotation Set to an NSNumber object whose value is the rotation, in radians, in the z axis. This field is identical to setting the rotation.z field.<br>scale.x Set to an NSNumber object whose value is the scale factor for the x axis.<br>scale.y Set to an NSNumber object whose value is the scale factor for the y axis.<br>scale.z Set to an NSNumber object whose value is the scale factor for the z axis.<br>scale Set to an NSNumber object whose value is the average of all three scale factors.<br>translation.x Set to an NSNumber object whose value is the translation factor along the x axis.<br>translation.y Set to an NSNumber object whose value is the translation factor along the y axis.<br>translation.z Set to an NSNumber object whose value is the translation factor along the z axis.<br>translation Set to an NSValue object containing an NSSize or CGSize data type. That data type indicates the amount to translate in the x and y axis<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对比这些keyPath不难发现,等价于第一章中<span class="type">UIView</span>封装的<span class="keyword">block</span>动画,不过要配以下方法:</span><br></pre></td></tr></table></figure></p>
<p>public func CGAffineTransformMakeTranslation(tx: CGFloat, _ ty: CGFloat) -&gt; CGAffineTransform</p>
<p>/<em> Return a transform which scales by `(sx, sy)’:<br>     t’ = [ sx 0 0 sy 0 0 ] </em>/</p>
<p>public func CGAffineTransformMakeScale(sx: CGFloat, _ sy: CGFloat) -&gt; CGAffineTransform</p>
<p>/<em> Return a transform which rotates by `angle’ radians:<br>     t’ = [ cos(angle) sin(angle) -sin(angle) cos(angle) 0 0 ] </em>/</p>
<p>public func CGAffineTransformMakeRotation(angle: CGFloat) -&gt; CGAffineTransform</p>
<p>/<em> Return true if `t’ is the identity transform, false otherwise. </em>/</p>
<p>public func CGAffineTransformIsIdentity(t: CGAffineTransform) -&gt; Bool</p>
<p>/<em> Translate <code>t&#39; by</code>(tx, ty)’ and return the result:<br>     t’ = [ 1 0 0 1 tx ty ] </em> t */</p>
<p>public func CGAffineTransformTranslate(t: CGAffineTransform, <em> tx: CGFloat, </em> ty: CGFloat) -&gt; CGAffineTransform</p>
<p>/<em> Scale <code>t&#39; by</code>(sx, sy)’ and return the result:<br>     t’ = [ sx 0 0 sy 0 0 ] </em> t */</p>
<p>public func CGAffineTransformScale(t: CGAffineTransform, <em> sx: CGFloat, </em> sy: CGFloat) -&gt; CGAffineTransform</p>
<p>/<em> Rotate <code>t&#39; by</code>angle’ radians and return the result:<br>     t’ =  [ cos(angle) sin(angle) -sin(angle) cos(angle) 0 0 ] </em> t */</p>
<p>public func CGAffineTransformRotate(t: CGAffineTransform, _ angle: CGFloat) -&gt; CGAffineTransform<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="escape">`t</span>ranslation<span class="escape">`对</span>应<span class="escape">`平</span>行移动<span class="escape">`;</span><span class="escape">`s</span>cale<span class="escape">`对</span>应<span class="escape">`缩</span>放<span class="escape">`;</span><span class="escape">`r</span>otation<span class="escape">`对</span>应<span class="escape">`旋</span>转<span class="escape">`.</span>  </span><br><span class="line">&lt;font color=<span class="string">"#ce1f48"</span>&gt;至于<span class="escape">`C</span>GAffineTransformMakeTranslation<span class="escape">`和</span><span class="escape">`C</span>GAffineTransformTranslate<span class="escape">`的</span>区别:前者每次都是以最初位置的中心点为起始参照,每次都是以传入的transform为起始参照&lt;/font&gt;    </span><br><span class="line">**&lt;font color=<span class="string">"orange"</span>&gt;举个栗子&lt;/font&gt;**</span><br></pre></td></tr></table></figure></p>
<pre><code>// 1.keyPath-translation
let basicAnimation = CABasicAnimation(keyPath: &quot;transform.translation.x&quot;)
basicAnimation.toValue = 200
basicAnimation.duration = 2.0
basicAnimation.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseInEaseOut)
basicAnimation.removedOnCompletion = false
basicAnimation.fillMode = kCAFillModeForwards
redView.layer.addAnimation(basicAnimation, forKey: nil)
// 1.block
UIView.animateWithDuration(2.0) { () -&gt; Void in
    self.blueView.transform = CGAffineTransformMakeTranslation(200.0, 0.0)
}

// 2.keyPath-rotation
let rotateAnimation = CABasicAnimation(keyPath: &quot;transform.rotation.y&quot;)// 绕y轴旋转
rotateAnimation.duration = 5.0
rotateAnimation.fromValue = 0.0
rotateAnimation.toValue = M_PI
redView.layer.addAnimation(rotateAnimation, forKey: nil)
// 2.block
UIView.animateWithDuration(5.0) { () -&gt; Void in
    // 必须用带3D的方法,这样处于立体坐标系
    self.blueView.layer.transform = CATransform3DMakeRotation(CGFloat(M_PI), 0.0, -1.0, 0.0)
    //CGAffineTransformMakeRotation(CGFloat(M_PI)) 平面旋转
}

// 3.keyPath-scale
let scaleAnimation = CABasicAnimation(keyPath: &quot;transform.scale&quot;)
scaleAnimation.duration = 1.0
scaleAnimation.autoreverses = true
scaleAnimation.fromValue = 1.0
scaleAnimation.toValue = 2.0
redView.layer.addAnimation(scaleAnimation, forKey: nil)
// 3.block
UIView.animateWithDuration(1.0, animations: { () -&gt; Void in
    self.blueView.transform = CGAffineTransformMakeScale(2.0, 2.0)
    }) { (_) -&gt; Void in
        UIView.animateWithDuration(1.0, animations: { () -&gt; Void in
            self.blueView.transform = CGAffineTransformMakeScale(1.0, 1.0)
        })
}
</code></pre><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">font</span> <span class="attribute">color</span>=<span class="value">"#ce1f48"</span>&gt;</span></span><span class="code">`CGAffineTransform是作用于View的主要为2D变换，而CATransform3D主要作用于Layer，为3D变换使用`</span><span class="xml"><span class="tag">&lt;/<span class="title">font</span>&gt;</span></span></span><br><span class="line">如图可见,是等价的,不过blcok形式虽然方便,功能却没keyPath形式强大,如果你操作复杂动画,还是用第一种方式比较好!    </span><br><span class="line">![<span class="link_label"></span>](<span class="link_url">http://7qn7zn.com1.z0.glb.clouddn.com/move_x.gif</span>)![<span class="link_label"></span>](<span class="link_url">http://7qn7zn.com1.z0.glb.clouddn.com/rotate_y.gif</span>)![](http://7qn7zn.com1.z0.glb.clouddn.com/scale.gif)  </span><br><span class="line">  </span><br><span class="line">这里提一下<span class="code">`CAAnimationGroup`</span>,它只有一个属性<span class="code">`public var animations: [CAAnimation]?`</span>,意思已经非常明了了,如果你想同时旋转+移动+缩放,就把上面3个animation放到这个数组中就可以了,就不加篇幅去具体介绍了...  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="header">### &lt;font color="#ce1f48"&gt;CAKeyframeAnimation&lt;/font&gt;  </span></span><br><span class="line">CABasicAnimation算是CAKeyFrameAnimation的特殊情况，即不考虑中间变换过程，只考虑起始点与目标点就可以了。而CAKeyFrameAnimation则更复杂一些，允许我们在起点与终点间自定义更多内容来达到我们的实际应用需求.最常见的就是虾米音乐点击音乐抛出一个🎵和淘宝点击一个物品自动抛入到购物车等(当初觉得好叼..知道真相的我眼泪掉下来).KeyFrame的意思是关键帧,举栗子可以理解为北斗七星之间连线,一共8个帧(指连成循环,第七星又连回第一星),改变每一帧对应状态,这样就不是单一的直线运动.  </span><br><span class="line">它的一些重要属性:  </span><br><span class="line"><span class="code">`values`</span>:存放整个动画过程中的关键帧点的数组,也就是动画路径    </span><br><span class="line"><span class="code">`path`</span>:同样是用于指定整个动画所经过的路径的,需要注意的是,values与path是互斥的,当values与path同时指定时,path会覆盖values,即values属性将被忽略(CGPath类型,可以去研究下CoreGraphics)  </span><br><span class="line"><span class="code">`keyTimes`</span>:动画时间数组,存放的是每一帧对应的时间,你没有显式地对keyTimes进行设置,则系统会默认每条子路径的时间为：ti=duration/(5-1)，即每条子路径的duration相等，都为duration的1\4.[0,0.1,0.5,1]对应的就是1-&gt;2:0.1 2-&gt;3:0.4 3-&gt;4:0.5  </span><br><span class="line"><span class="code">`timingFunctions`</span>:老熟人了,参见前面文章  </span><br><span class="line"><span class="code">`calculationMode`</span>:来设定关键帧中间的值是怎么被计算的(不太懂,参考下:[<span class="link_label">这里</span>](<span class="link_url">http://blog.csdn.net/smking/article/details/8424851</span>))</span><br></pre></td></tr></table></figure>
<pre><code>kCAAnimationLinear // 默认值,表示当关键帧为座标点的时候,关键帧之间直接直线相连进行插值计算;
kCAAnimationDiscrete // 离散的,就是不进行插值计算,所有关键帧直接逐个进行显示;
kCAAnimationPaced // 使得动画均匀进行,而不是按keyTimes设置的或者按关键帧平分时间,此时keyTimes和timingFunctions无效;
kCAAnimationCubic // 对关键帧为座标点的关键帧进行圆滑曲线相连后插值计算,对于曲线的形状还可以通过tensionValues,continuityValues,biasValues来进行调整自定义,这里的数学原理是Kochanek–Bartels spline,这里的主要目的是使得运行的轨迹变得圆滑;
kCAAnimationCubicPaced // 看这个名字就知道和kCAAnimationCubic有一定联系,其实就是在kCAAnimationCubic的基础上使得动画运行变得均匀,就是系统时间内运动的距离相同,此时keyTimes以及timingFunctions也是无效的.
</code></pre><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`rotationMode`:Possible values are <span class="keyword">*</span>auto<span class="keyword">*</span> and <span class="keyword">*</span>autoReverse<span class="keyword">*</span>. Defaults to nil.我是这样理解,飞机按路径飞行(方向从左往右),如果你不设置rotationMode,那么飞机只会是永远和X轴平行,反之设置了,那么飞机头就会随路径变化而变化  </span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="variable">&lt;font color="orange"&gt;</span>再举个栗子<span class="variable">&lt;/font&gt;</span><span class="keyword">*</span><span class="keyword">*</span></span><br></pre></td></tr></table></figure>
<pre><code>let animationTest = CAKeyframeAnimation(keyPath: &quot;position&quot;)
let pathTest = CGPathCreateMutable()
CGPathMoveToPoint(pathTest, nil, 20, 20)
CGPathAddCurveToPoint(pathTest, nil, 160, 30, 220, 220, 240, 380) // 贝塞尔曲线,起始点+控制点
animationTest.path = pathTest
animationTest.duration = 10.0
animationTest.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseIn)
animationTest.rotationMode = &quot;auto&quot;
redView.layer.addAnimation(animationTest, forKey: nil)
</code></pre><p><code>``  
两种结果来说明</code>rotationMode<code>的效果.第一张为</code>auto`,第二张默认为nil<br><img src="http://7qn7zn.com1.z0.glb.clouddn.com/keyframe_auto.gif" alt=""><img src="http://7qn7zn.com1.z0.glb.clouddn.com/keyframe_no_auto.gif" alt=""><br>更多的动画效果就不一一展示了,大家去随便试验玩起来吧.  </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>title: iOS CoreAnimation(四)之CAPropertyAnimation<br>date: 2015-11-04 14:31:26<br>categories: CoreAnimation </p>
<h2 id="tags_3A_Basic_KeyF]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Facebook POP使用介绍]]></title>
    <link href="http://hmttommy.com/2015/11/26/facebookpop/"/>
    <id>http://hmttommy.com/2015/11/26/facebookpop/</id>
    <published>2015-11-26T03:14:23.000Z</published>
    <updated>2015-11-27T04:16:07.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u5951_u673A"><a href="#u5951_u673A" class="headerlink" title="契机"></a><font color="IndianRed">契机</font></h3><p>项目最近加了个需求,统计所得收益的金额(LZ做的app金融属性很强)要像余额宝一样带跳动效果.网上找到篇文章可以实现<a href="http://www.tuicool.com/articles/uARRrq" target="_blank" rel="external">这里</a>,不过感觉很麻烦,再查了一下说<a href="https://github.com/facebook/pop" target="_blank" rel="external">POP</a>可以实现,顺便来介绍下,虽然已经出来很久了…so-&gt;上Demo<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">        let numberJumpAnimation = POPBasicAnimation()</span><br><span class="line">        numberJumpAnimation.fromValue = <span class="number">0</span></span><br><span class="line">        numberJumpAnimation.toValue = <span class="number">267493.32</span></span><br><span class="line">        numberJumpAnimation.duration = <span class="number">2.0</span></span><br><span class="line"><span class="label">        numberLabel.pop_addAnimation(numberJumpAnimation, forKey:</span> <span class="string">"numberJumpAnimation"</span>)</span><br><span class="line">        </span><br><span class="line">        let prop = POPMutableAnimatableProperty()</span><br><span class="line">        prop.name = <span class="string">"jump number"</span></span><br><span class="line"><span class="label">        prop.writeBlock = &#123; (obj:AnyObject!,values:</span>UnsafePointer&lt;CGFloat&gt;) -&gt; Void in</span><br><span class="line">            let label = obj as! UILabel</span><br><span class="line">            label.text = String(round(values[<span class="number">0</span>]*<span class="number">100</span>)/<span class="number">100</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        prop.threshold = <span class="number">0.01</span><span class="comment">;</span></span><br><span class="line">        numberJumpAnimation.property = prop</span><br><span class="line"><span class="escape">``</span><span class="escape">` </span> </span><br><span class="line"><span class="label">效果如下:</span>  </span><br><span class="line"><span class="label">&lt;center&gt;![](http:</span>//<span class="number">7</span>qn7zn.com1.z0.glb.clouddn.com/numberjump.gif)&lt;/center&gt;    </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">### &lt;font color=<span class="string">"IndianRed"</span>&gt;Facebook出品 必属精品&lt;/font&gt;  </span><br><span class="line"><span class="escape">`F</span>acebook POP<span class="escape">`是</span>基于<span class="escape">`C</span>ADisplayLink<span class="escape">`实</span>现的独立于Core Animation之外的动画引擎.<span class="escape">`P</span>OP<span class="escape">`在</span>使用上和Core Animation很相似,都涉及Animation对象以及Animation的载体的概念,&lt;font color=<span class="string">"#ce1f48"</span>&gt;不同的是Core Animation的载体只能是<span class="escape">`C</span>ALayer<span class="escape">`,</span>而<span class="escape">`P</span>OP<span class="escape">` </span>可以是任意基于<span class="escape">`N</span>SObject<span class="escape">`的</span>对象.&lt;/font&gt;  </span><br><span class="line"><span class="escape">`P</span>OP<span class="escape">`支</span>持<span class="number">4</span>种类型:</span><br></pre></td></tr></table></figure></p>
<p>POPBasicAnimation<br>POPSpringAnimation<br>POPDecayAnimation<br>POPCustomAnimation<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!--more--&gt;</span></span></span><br><span class="line">PS:对于<span class="code">`CADisplayLink`</span>,LZ也不了解,搜了几遍文章附上链接,有兴趣的可以去看看  </span><br><span class="line"> + [<span class="link_label">CADisplayLink</span>](<span class="link_url">http://www.jianshu.com/p/c35a81c3b9eb</span>)  </span><br><span class="line"> + [<span class="link_label">使用CADisplayLink实现果冻效果动画</span>](<span class="link_url">http://www.cocoachina.com/ios/20150320/11382.html</span>)  </span><br><span class="line"> + [<span class="link_label">CADisplayLink结合UIBezierPath的神奇妙用</span>](<span class="link_url">http://kittenyang.com/cadisplaylinkanduibezierpath/</span>)  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="header">### &lt;font color="IndianRed"&gt;POPBasicAnimation&lt;/font&gt;  </span></span><br><span class="line">基本动画,接口方面和<span class="code">`CABasicAniamtion`</span>很相似，有<span class="code">`fromValue toValue duration timingFunction`</span>等属性..(也可以参照我[<span class="link_label">前面的文章</span>](<span class="link_url">http://www.hmttommy.com/2015/06/03/iOS-CoreAnimation-三-之CAAnimation/</span>),详细介绍了<span class="code">`timingFunction`</span>)  </span><br><span class="line"><span class="strong">**&lt;font color="orange"&gt;举个栗子&lt;/font&gt;**</span></span><br></pre></td></tr></table></figure></p>
<pre><code>let moveYAnimation = POPBasicAnimation(propertyNamed: kPOPLayerPositionY)
moveYAnimation.toValue = 500
moveYAnimation.duration = 3.0
// 先慢-&gt;快-&gt;再慢
moveYAnimation.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseInEaseOut)
numberLabel.pop_addAnimation(moveYAnimation, forKey: &quot;MovePositionY&quot;)
</code></pre><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">效果如下:</span>  </span><br><span class="line"><span class="label">&lt;center&gt;![](http:</span>//<span class="number">7</span>qn7zn.com1.z0.glb.clouddn.com/basePop.gif)&lt;/center&gt;  </span><br><span class="line">对于参数<span class="escape">`p</span>ropertyNamed<span class="escape">`,</span>可以参照<span class="escape">`P</span>OPAnimatableProperty.h<span class="escape">`文</span>件,都是<span class="escape">`P</span>OP<span class="escape">`默</span>认支持属性的动画</span><br></pre></td></tr></table></figure>
<p>// Common CALayer property names.</p>
<p>extern NSString <em> const kPOPLayerBackgroundColor;<br>extern NSString </em> const kPOPLayerBounds;<br>extern NSString <em> const kPOPLayerCornerRadius;<br>extern NSString </em> const kPOPLayerBorderWidth;<br>extern NSString <em> const kPOPLayerBorderColor;<br>extern NSString </em> const kPOPLayerOpacity;<br>extern NSString <em> const kPOPLayerPosition;<br>extern NSString </em> const kPOPLayerPositionX;<br>extern NSString * const kPOPLayerPositionY;<br>//………..太多了,不一一列举  ……………//<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="preprocessor">### &lt;font color=<span class="string">"IndianRed"</span>&gt;POPSpringAnimation&lt;/font&gt;  </span></span><br><span class="line">弹簧动画,iOS7后系统也出了个`public class <span class="function"><span class="keyword">func</span> <span class="title">animateWithDuration</span><span class="params">(duration: NSTimeInterval, delay: NSTimeInterval, usingSpringWithDamping dampingRatio: CGFloat, initialSpringVelocity velocity: CGFloat, options: UIViewAnimationOptions, animations: ()</span> -&gt; <span class="title">Void</span>, <span class="title">completion</span>: <span class="params">((Bool)</span> -&gt; <span class="title">Void</span>)?)`.我最初了解到`<span class="title">POP</span>`就是因为它能很好很方便的实现弹簧动画.先来看下一它专属的几个属性:  </span></span><br><span class="line">&lt;font color=<span class="string">"red"</span>&gt;PS:POPSpringAnimation是没有`duration`字段的,动画持续时间由以下几个参数决定&lt;/font&gt;</span><br></pre></td></tr></table></figure></p>
<p>CGFloat springBounciness;// 弹簧弹力,值越大震动幅度越大 范围为[0, 20]，默认值为4<br>CGFloat springSpeed;// 弹簧速度,速度越快动画时间越短 范围为[0, 20]，默认为12<br>//  上面两个属性一起决定着弹簧动画的效果<br>CGFloat dynamicsTension;// 弹簧的张力<br>CGFloat dynamicsFriction;// 弹簧的摩擦力<br>CGFloat dynamicsMass;// 弹簧的质量<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="variable">&lt;font color="orange"&gt;</span>举个栗子<span class="variable">&lt;/font&gt;</span><span class="keyword">*</span><span class="keyword">*</span></span><br></pre></td></tr></table></figure></p>
<pre><code>let springAnimation = POPSpringAnimation(propertyNamed: kPOPLayerPositionY)
springAnimation.toValue = 500
springAnimation.springBounciness = 16
springAnimation.springSpeed = 1
numberLabel.pop_addAnimation(springAnimation, forKey: &quot;springAnimation&quot;)
</code></pre><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">效果如下:</span>  </span><br><span class="line"><span class="label">&lt;center&gt;![](http:</span>//<span class="number">7</span>qn7zn.com1.z0.glb.clouddn.com/SpingPop.gif)&lt;/center&gt;  </span><br><span class="line">更多栗子就不举了...    </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">### &lt;font color=<span class="string">"IndianRed"</span>&gt;POPDecayAnimation&lt;/font&gt;  </span><br><span class="line">我称它为滑动衰减动画.UIKit中最常见这种状态的就是<span class="escape">`U</span>IScrollView<span class="escape">`了</span>.对<span class="escape">`P</span>OPDecayAnimation<span class="escape">`设</span>置toValue是没有意义的 会被忽略,因为目的状态是动态计算得到的,&lt;font color=<span class="string">"red"</span>&gt;它也是没有<span class="escape">`d</span>uration<span class="escape">`字</span>段的 其动画持续时间由<span class="escape">`v</span>elocity与deceleration<span class="escape">`决</span>定&lt;/font&gt;</span><br></pre></td></tr></table></figure>
<p>velocity // 速率,必须和你操作的属性有相同的结构<br>deceleration // 衰减系数(负加速度),越小则衰减得越快,默认是0.998,一般不去修改<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="variable">&lt;font color="orange"&gt;</span>举个栗子<span class="variable">&lt;/font&gt;</span><span class="keyword">*</span><span class="keyword">*</span></span><br></pre></td></tr></table></figure></p>
<pre><code>有种刹车的感觉
let decayAnimation = POPDecayAnimation(propertyNamed: kPOPLayerPositionY)
decayAnimation.velocity = 3600
decayAnimation.deceleration = 0.998
numberLabel.pop_addAnimation(decayAnimation, forKey: &quot;decayAnimation&quot;)
</code></pre><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">  </span><br><span class="line">### &lt;font color=<span class="string">"IndianRed"</span>&gt;POPCustomAnimation&lt;/font&gt;  </span><br><span class="line">自定义动画,我们开头举的例子就是属于这一类.主要是通过<span class="escape">`P</span>OPAnimatableProperty<span class="escape">`定</span>义属性,然后设定<span class="escape">`r</span>eadBlock<span class="escape">`和</span><span class="escape">`w</span>riteBlock<span class="escape">`.</span>  </span><br><span class="line"><span class="label">针对文章开头例子分析:</span></span><br></pre></td></tr></table></figure>
<p>readBlock // 当前的属性值<br>writeBlock // 修改变化后的属性值<br>threashold // 值越大writeBlock的调用次数越少,默认不去设定<br><code>`` </code>obj<code>就是我们的Label,</code>values<code>这个是动画作用的属性数组,这里我们只需要操作Label上显示的文字，所以只需要一个参数为</code>values[0]<code>,如果是多个比如CGRectMake(x,x,x,x),则是</code>values[0] values[1] values[2] values[3]<code>了.  
是不是非常的简单!</code>PNChat<code>里面使用的是一个</code>UICountingLabel`的第三方,也能实现这个效果.<br>更多的自定义动画就等大家去探讨了,LZ工作过程中有新的动画也会继续加进来  </p>
<h3 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a><font color="IndianRed">参考链接</font></h3><blockquote>
<p><a href="https://github.com/facebook/pop" target="_blank" rel="external">pop</a><br><a href="https://www.youtube.com/watch?v=gmNhs052nfY" target="_blank" rel="external">pop_youtube</a>(请自备梯子)<br><a href="http://www.cocoachina.com/ios/20140704/9034.html" target="_blank" rel="external">Facebook POP 进阶指南</a><br><a href="http://www.cocoachina.com/industry/20140527/8565.html" target="_blank" rel="external">Facebook Pop 使用指南</a>  </p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u5951_u673A"><a href="#u5951_u673A" class="headerlink" title="契机"></a><font color="IndianRed">契机</font></h3><p>项目最近加了个需求,统计所得收益的金额(L]]>
    </summary>
    
      <category term="pop" scheme="http://hmttommy.com/tags/pop/"/>
    
      <category term="Animation" scheme="http://hmttommy.com/categories/Animation/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[设计模式(三)之单例模式(译)]]></title>
    <link href="http://hmttommy.com/2015/11/15/TheSinInSingleton/"/>
    <id>http://hmttommy.com/2015/11/15/TheSinInSingleton/</id>
    <published>2015-11-15T06:59:53.000Z</published>
    <updated>2015-11-26T03:13:41.000Z</updated>
    <content type="html"><![CDATA[<p>想来总结单例模式,但它可能是我们最早接触却也是随知识增长而变得最嫌弃的设计模式了.(据说去面试的时候,面试官问你用到过什么设计模式,如果你只答单例,会被鄙视)<br>看到一遍文章,讲的很不错,就拿来翻译一下(个人英语略挫,不要嫌弃…)<br>@列出单例的写法:<br>oc版<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)sharedInstance</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> once;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">id</span> sharedInstance;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;once, ^&#123;</span><br><span class="line">        sharedInstance = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> sharedInstance;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">Swift版</span><br></pre></td></tr></table></figure></p>
<p>class SharedInstance  {<br>    private static let signleModel = SharedInstance()<br>    class var sharedInstance : SharedInstance {<br>        return signleModel<br>    }<br>}<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原文:[<span class="link_label">The Sin in Singleton</span>](<span class="link_url">https://sandofsky.com/blog/singletons.html#161c:fn:1</span>)  </span><br><span class="line">再推荐一篇objc.io的文章:[<span class="link_label">避免滥用单例</span>](<span class="link_url">http://objccn.io/issue-13-2/</span>)  </span><br><span class="line">  </span><br><span class="line">单例并不是一种"反模式",但它却是一种"被滥用"的模式.它的方便性使得它很受初学者的欢迎.但它们增加了复杂性的下线,并且带来了令人抓狂的bug.  </span><br><span class="line">  </span><br><span class="line">让我们从它的正面性开始讲起.有时,你需要保持一个对象有一个且仅有一个实例来表示.比如<span class="code">`UIApplication:`</span></span><br></pre></td></tr></table></figure></p>
<p>UIApplication.sharedApplication.applicationIconBadgeNumber = 0<br>UIApplication.sharedApplication.applicationIconBadgeNumber = 1<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这样可能能够更加说明:  </span><br><span class="line"><span class="comment">&lt;!--more--&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>let firstInstance = UIApplication()<br>firstInstance.applicationIconBadgeNumber = 0</p>
<p>let secondInstance = UIApplication()<br>secondInstance.applicationIconBadgeNumber = 1<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="escape">`f</span>irstInstance == secondInstance<span class="escape">`总</span>是返回ture吗?当更改其中一个的值,另一个的值是也会更新吗?  </span><br><span class="line">  </span><br><span class="line"><span class="label">当单例代表了一个无所不在(全局)的对象,一个永远不会被改变的对象,那么这可能是一个恰当的比喻:</span>像当前的应用程序/设备的加速度计或者你的上帝^_^.  </span><br><span class="line">  </span><br><span class="line">少数情况下,你需要在你的app共享一个服务.<span class="escape">`N</span>SNotificationCenter<span class="escape">`仅</span>仅工作在一个单一的广播在所有的边界情况下,这也是为什么	<span class="escape">`c</span>enter<span class="escape">`这</span>个词出现在它的命名中.  </span><br><span class="line">  </span><br><span class="line">但在其他情况下,不使用单例模式.  </span><br><span class="line">  </span><br><span class="line">有时我看到<span class="escape">`U</span>ser.currentUser<span class="escape">`或</span><span class="escape">`A</span>ccount.sharedAccount<span class="escape">`代</span>表当前登录的用户,我不怪你.因为它是如此方便.</span><br></pre></td></tr></table></figure></p>
<p>class NewsFeedController:UIViewController {<br>  func didPullToRefresh(sender:AnyObject){<br>    Account.currentAccount.newsFeed.loadNewer()<br>  }<br>}<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">但<span class="keyword">*</span><span class="keyword">*</span>账户并不是单例<span class="keyword">*</span><span class="keyword">*</span>,用户可以注销账户(我理解是,你要杀死上帝吗?).很多app描述注销的体验通过一种特殊的类型账户.服务发展到同时支持多个账户.账户是不稳定的,它作为单例就是个谎言...  </span><br><span class="line">  </span><br><span class="line">但如果账户真的就是一个单例,那么就不会是问题了:</span><br></pre></td></tr></table></figure></p>
<p>Account.currentAccount.networkAPI.validatePhoto(photo) {<br>  newPhoto, errorOrNil in<br>  guard errorOrNil == nil else { return }<br>  Account.currentAccount.networkAPI.updatePhoto(newPhoto)<br>}<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果那张请求的照片被缓慢的网路开了个玩笑花费了几分钟,并在这过程中用户切换了账户,会是什么情况?错误的账户得到了照片资料.  </span><br><span class="line">  </span><br><span class="line">单例是一个奇特的<span class="escape">`全</span>局变量<span class="escape">`.</span>有的时候/少数情况下,全局变量是必须的,但你应该尽量的避免它.单例是困难的,再去共享这个状态是很难很难的...</span><br></pre></td></tr></table></figure></p>
<p>class HomeViewController:UIViewController {<br>  override func viewWillAppear(animated:Bool){<br>    super.viewWillAppear(animated)<br>    Analytics.sharedAnalytics.currentViewController = self<br>  }</p>
<p>  func didTapLike(sender:AnyObject) {<br>    Analytics.sharedAnalytics.recordEvent(.TappedLike)<br>  }<br>}</p>
<p>// An Alert Modal that can pop up any time<br>class IncomingMessagePrompt:UIViewController {<br>  override func viewWillAppear(animated:Bool){<br>    super.viewWillAppear(animated)<br>    Analytics.sharedAnalytics.currentViewController = self<br>  }</p>
<p>  func didTapReply(sender:AnyObject) {<br>    Analytics.sharedAnalytics.recordEvent(.TappedReply)<br>  }<br>}<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">自定义容器视图控制器使得`viewWillAppear`难以预料.导航控制器自带边界手势:</span>如果你一开始利用<span class="escape">`s</span>wipe<span class="escape">`手</span>势返回,但是过程中改变了主意,取消返回手势,那么你会得到一个错误的<span class="escape">`v</span>iewWillAppear<span class="escape">`,</span>而且你打印的事件日志也是来自于错误的viewController.  </span><br><span class="line"><span class="label">这样更好:</span></span><br></pre></td></tr></table></figure></p>
<p>func didTapReply(sender:AnyObject) {<br>  Analytics.sharedAnalytics.recordEvent(.TappedReply, fromViewController:self)<br>}<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">但真实的情况是你常常需要这种情况.也许你的分析团队发现了重复点击,却要求你只能记录一次.<span class="escape">`T</span>appedReply once per view controller instance.<span class="escape">`(</span>没看懂这句话...)</span><br></pre></td></tr></table></figure></p>
<p>class IncomingMessagePrompt:UIViewController {<br>  lazy var analytics:Analytics = { Analytics(controller:self) }()<br>  func didTapReply(sender:AnyObject){<br>    analytics.recordEvent(.TappedReply)<br>  }<br>}<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在实际情况中,也许你想保持所有的分析请求在一个单一的队列去调试它们.也行单例状态是可以接受的,但请至少降低它的影响范围</span><br></pre></td></tr></table></figure></p>
<p>Analytics(controller:self, queue:AnalyticsQueue.sharedQueue)<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">在我重构时弄出个非常有趣的<span class="string">bug:</span></span><br></pre></td></tr></table></figure></p>
<p>class Account:NSObject {<br>  static sharedAccount = Account()<br>  var homeTimeline:Timeline()<br>  var preferences:AccountPreference<br>  init(){<br>      preferences = AccountPreference.loadFromDisk()<br>      homeTimeline = Timeline()<br>      super.init()<br>  }<br>}</p>
<p>class Timeline:NSObject {<br>  init(){<br>    self.orderPreference = Account.sharedAccount.preferences.timelineOrder<br>    super.init()<br>  }<br>}<br><code>``  
这段代码初始化失败,因为我们在初始化的过程中</code>Timeline`对象就去接受账户单例实例的赋值.可以想象到在更深的对象层中这种”情况”.  </p>
<p>如果我们想要对<code>Timeline</code>做单元测试应该怎样呢?<br>如果任何一个人都可以获取明确关系的对象,那么所有的对象都会因隐藏的依赖关系变得纠结…  </p>
<p>对于非常简单的app,你可能永远都不会遇到单例的问题.当你第一次建立app工程时,最好的做法似乎都有那么些小题大做.有人会告诉你,”你不会需要它的”.”你总是可以重构的”…  </p>
<p>根据我的经验来看,相比第一时间把事情做对,这显然是非常难以偿还的技术债务.当你把自己限制在一个范围中,这时你的产品经理要求你迅速的改一个需求,there’s a lot of pressure to slap on just one hack.(实在是不知道怎么翻译这句话)  </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>想来总结单例模式,但它可能是我们最早接触却也是随知识增长而变得最嫌弃的设计模式了.(据说去面试的时候,面试官问你用到过什么设计模式,如果你只答单例,会被鄙视)<br>看到一遍文章,讲的很不错,就拿来翻译一下(个人英语略挫,不要嫌弃…)<br>@列出单例的写法:<br>oc版]]>
    </summary>
    
      <category term="单例" scheme="http://hmttommy.com/tags/%E5%8D%95%E4%BE%8B/"/>
    
      <category term="设计模式" scheme="http://hmttommy.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://hmttommy.com/2015/11/11/%E5%9F%BA%E4%BA%8E%E9%A1%B9%E7%9B%AE%E6%9F%90%E5%A4%84%E5%9B%BE%E7%89%87%E6%B5%8F%E8%A7%88%E9%9C%80%E6%B1%82%E5%BC%95%E5%8F%91%E7%9A%84%E8%9B%8B%E7%96%BC/"/>
    <id>http://hmttommy.com/2015/11/11/基于项目某处图片浏览需求引发的蛋疼/</id>
    <published>2015-11-11T08:32:41.000Z</published>
    <updated>2015-11-11T08:32:41.000Z</updated>
    <content type="html"><![CDATA[<p>title: 基于项目某处图片浏览需求引发的XX<br>date: 2015-11-06 16:42:19<br>categories: Push/Pop/Present/Dismiss </p>
<h2 id="tags_3A__u56FE_u7247_u6D4F_u89C8_Custom_push"><a href="#tags_3A__u56FE_u7247_u6D4F_u89C8_Custom_push" class="headerlink" title="tags: 图片浏览 Custom push"></a>tags: 图片浏览 Custom push</h2><p>一直以来都在想懂微信/新浪微博点击图片放大浏览的效果究竟是怎么样的,碰巧项目最近遇到一种类似的情况,就动手实践了下,在尝试了各种设置而出现的奇葩效果,暂时性的实现了一种还算丝滑过渡效果.<br>效果如下:最后一张是最终要的(如果有更好的实现方法,可以留言给我,强烈渴望中…)我把速度放了很慢,这样能够更清楚看清过渡过程<br><img src="http://7qn7zn.com1.z0.glb.clouddn.com/brown_photo_1.gif" alt=""><img src="http://7qn7zn.com1.z0.glb.clouddn.com/brown_photo_2.gif" alt=""><img src="http://7qn7zn.com1.z0.glb.clouddn.com/brown_photo_3.gif" alt=""><br><img src="http://7qn7zn.com1.z0.glb.clouddn.com/brown_photo_4.gif" alt=""><img src="http://7qn7zn.com1.z0.glb.clouddn.com/brown_photo_5.gif" alt=""><img src="http://7qn7zn.com1.z0.glb.clouddn.com/brown_photo_final.gif" alt=""><br><strong><font color="red">“所以,所以,罪魁祸首就是,你拍的照片不管是竖屏还是横屏的都要在高200宽等屏幕宽的view上展示,这导致push前后UIImageView的<code>contentMode</code>样式不统一的悲剧”</font></strong><br><a id="more"></a><br>不明白?好吧,我们一张一张来说明,在此之前再来看一张图,说明一下横竖拍照片展示样式的问题:<br><img src="http://7qn7zn.com1.z0.glb.clouddn.com/uiimageview_contentMode.png" alt=""><br>PS:这里统一讨论<code>W:375(屏幕宽,以iPhone6为例),H:375*0.66</code>的放大前UIImageView(以下写作frontIm)和<code>W:ScreenSize.width,H:ScreenSize.height</code>的放大后的UIImageView(以下写作backIm).  </p>
<ul>
<li>contentMode都设置为<code>.ScaleAspectFill</code>时:  <ul>
<li>横拍照片和竖拍照片在frontIm中都可以饱满的展示;但是横拍照片在backIm中就会被拉伸(如图4),竖拍的也会被拉伸  </li>
</ul>
</li>
<li>contentMode都设置为<code>.ScaleAspectFit</code>时:  <ul>
<li>frontIm中横拍照片依旧能够饱满展示,但是竖拍照片就会如上图所示,显示在中间,旁边为空白(这样没有丢失精度);backIm中都正常显示(如图5和图6)  </li>
</ul>
</li>
</ul>
<p>再回过头来看看前面六张图:<br>1.展示的是一张竖拍图,在frontIm中contentMode为.ScaleAspectFill;在backIm中contentMode为.ScaleAspectFit(这个时候正常显示了,但是过程太难看了,原因就是contentMode不一致)<br>2.展示的是一张竖拍图,在frontIm中contentMode为.ScaleAspectFill;在backIm中contentMode为.ScaleAspectFit(这个时候backIm的宽高设置成和frontIm一样,所以转场过程显示的略平滑)<br>3.展示的是一张竖拍图,在frontIm和backIm中contentMode都为.ScaleAspectFill,并且它们的高度都被设置为<code>W:375 H:375*0.66</code>,这个时候转场平滑+图片没有异变,可是,竖拍的图片明显显示不全,被截了.<br>4.展示的是一张横拍图,在frontIm中contentMode为.ScaleAspectFill/.ScaleAspectFit(可见横拍图并不受影响);在backIm中contentMode为.ScaleAspectFill(被无情的拉伸了…)<br>5.同上,除了把backIm中contentMode改为.ScaleAspectFit,结果是ok的<br>6.最终所要的效果,在frontIm中contentMode为.ScaleAspectFill;在backIm中contentMode为.ScaleAspectFit,不同第一张的是在转场的过程中做了变化!前面已经提到了,如果contentMode设置的不一样,那么转场的过程就会出现跳变效果(很丑),所以针对这种情况在点击浏览它的时候重新生成一个图片作为转场的截图,把<code>contentMode设置为一样</code>,这样就ok了!  </p>
<p>@代码如下:@  </p>
<pre><code>class TYBrownPhotoTransition: NSObject,UIViewControllerAnimatedTransitioning {

    var snapImageView: UIImageView?
    var popType: UINavigationControllerOperation?

    override init() {
        super.init()
    }

    convenience init(imageView: UIImageView,popType: UINavigationControllerOperation?) {
        self.init()
        self.snapImageView = imageView
        self.popType = popType
    }

    func transitionDuration(transitionContext: UIViewControllerContextTransitioning?) -&gt; NSTimeInterval {
        return 0.3
    }

    func animateTransition(transitionContext: UIViewControllerContextTransitioning) {
        //  放大
        if popType == .Push {
            let fromVC = transitionContext.viewControllerForKey(UITransitionContextFromViewControllerKey) as! WCDetailDreamViewController
            let toVC = transitionContext.viewControllerForKey(UITransitionContextToViewControllerKey) as! WCBrownPhotoViewController
            let containerView = transitionContext.containerView()

            //  获取图片的截图
            //let snapshotHeadView = fromVC.headScrollView.snapshotViewAfterScreenUpdates(TyBool.False)
            //  类似于微信,假如9张图片的朋友圈信息,你点击每个图片浏览,它们都是从对应的位置出来放大,就是通过下面这个方法来获取的坐标
            //snapshotHeadView.frame =  containerView!.convertRect(fromVC.headScrollView.frame, fromView: fromVC.headScrollView.superview)

            //  在点击图片的时候,生成imageView,然后传入转场动画中
            let testImageView = snapImageView!
            fromVC.headScrollView.hidden = TyBool.True
            toVC.view.frame = transitionContext.finalFrameForViewController(toVC)
            toVC.testImageView.hidden = TyBool.True
            containerView!.addSubview(toVC.view)
            containerView!.addSubview(testImageView)
            //containerView!.addSubview(snapshotHeadView)

            UIView.animateWithDuration(transitionDuration(transitionContext), animations: { () -&gt; Void in
                toVC.view.alpha = 1.0
                //let frame = containerView!.convertRect(toVC.testImageView.frame, fromView: toVC.view)
                //snapshotHeadView.frame = frame
                testImageView.center = CGPointMake(ScreenSize.width/2, ScreenSize.height/2)
                testImageView.transform = CGAffineTransformMakeScale(2.0, 2.0)
                }) { (_) -&gt; Void in
                    toVC.testImageView.hidden = TyBool.False
                    fromVC.headScrollView.hidden = TyBool.False
                    //  动画结束之后就可以移除掉作为转场的截图
                    testImageView.removeFromSuperview()
                    //snapshotHeadView.removeFromSuperview()
                    //  别忘记这个了,告之转场结束
                    transitionContext.completeTransition(!transitionContext.transitionWasCancelled())
            }
        } else {
            //  缩小(暂不举例)
        }
    }
}

        headScrollView = {
            let scrollView = WCHeadDearmDetailScrollView(imageList: [&quot;i_love_you.jpg&quot;,&quot;h2&quot;,&quot;h3&quot;,&quot;h4&quot;], tapImageClosure: {[weak self] image in
                if let weakSelf = self {
                    weakSelf.tapImageView = UIImageView.snapShowBigImageView(image)

                    let brownPhotoVC = WCBrownPhotoViewController()
                    brownPhotoVC.imageTest = image
                    weakSelf.navigationController!.pushViewController(brownPhotoVC, animated: true)
                }
            })

extension UIImageView {
    //  针对梦想详情界面的图片放大浏览
    class func snapShowBigImageView(image:UIImage) -&gt; UIImageView {
        let x = (ScreenSize.width - ScreenSize.width / 2) / 2
        let tapImageView = UIImageView(frame: CGRectMake(x, 0, ScreenSize.width/2, ScreenSize.height/2))
        tapImageView.image = image
        tapImageView.contentMode = .ScaleAspectFit
        tapImageView.clipsToBounds = TyBool.True
        return tapImageView
    }
}

        testImageView = {
            let imageView = UIImageView(frame: CGRectMake(0, 0, ScreenSize.width, ScreenSize.height))
            imageView.image = imageTest!
                //UIImage(named: imageUrl!)
            imageView.contentMode = .ScaleAspectFit
            self.view.addSubview(imageView)
            imageView.userInteractionEnabled = TyBool.True
            let tap = UITapGestureRecognizer(target: self, action: &quot;test&quot;)
            imageView.addGestureRecognizer(tap)
            return imageView
        }()

// MARK: - CustomModal Transition
private typealias CustomModalTransition = WCDetailDreamViewController
extension CustomModalTransition: UINavigationControllerDelegate {
    override func viewDidAppear(animated: Bool) {
        super.viewDidAppear(animated)
        self.navigationController!.delegate = self
    }

    override func viewWillDisappear(animated: Bool) {
        super.viewWillDisappear(animated)
        self.navigationController!.delegate = nil
    }

    func navigationController(navigationController: UINavigationController, animationControllerForOperation operation: UINavigationControllerOperation, fromViewController fromVC: UIViewController, toViewController toVC: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? {
        if toVC.isKindOfClass(WCBrownPhotoViewController.self) {
            return TYBrownPhotoTransition(imageView: tapImageView, popType: .Push)
        } else {
            return nil
        }
    }
}
</code></pre><p>PS:对于Custom转场不了解的,可以去看一下<a href="http://www.hmttommy.com/2015/05/29/iOS-CoreAnimation-02/" target="_blank" rel="external">iOS CoreAnimation(二)之CATransition</a>的前半部分  </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>title: 基于项目某处图片浏览需求引发的XX<br>date: 2015-11-06 16:42:19<br>categories: Push/Pop/Present/Dismiss </p>
<h2 id="tags_3A__u56FE_u7247_u6D4F_u89C8_Custom_push"><a href="#tags_3A__u56FE_u7247_u6D4F_u89C8_Custom_push" class="headerlink" title="tags: 图片浏览 Custom push"></a>tags: 图片浏览 Custom push</h2><p>一直以来都在想懂微信/新浪微博点击图片放大浏览的效果究竟是怎么样的,碰巧项目最近遇到一种类似的情况,就动手实践了下,在尝试了各种设置而出现的奇葩效果,暂时性的实现了一种还算丝滑过渡效果.<br>效果如下:最后一张是最终要的(如果有更好的实现方法,可以留言给我,强烈渴望中…)我把速度放了很慢,这样能够更清楚看清过渡过程<br><img src="http://7qn7zn.com1.z0.glb.clouddn.com/brown_photo_1.gif" alt=""><img src="http://7qn7zn.com1.z0.glb.clouddn.com/brown_photo_2.gif" alt=""><img src="http://7qn7zn.com1.z0.glb.clouddn.com/brown_photo_3.gif" alt=""><br><img src="http://7qn7zn.com1.z0.glb.clouddn.com/brown_photo_4.gif" alt=""><img src="http://7qn7zn.com1.z0.glb.clouddn.com/brown_photo_5.gif" alt=""><img src="http://7qn7zn.com1.z0.glb.clouddn.com/brown_photo_final.gif" alt=""><br><strong><font color="red">“所以,所以,罪魁祸首就是,你拍的照片不管是竖屏还是横屏的都要在高200宽等屏幕宽的view上展示,这导致push前后UIImageView的<code>contentMode</code>样式不统一的悲剧”</font></strong><br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://hmttommy.com/2015/10/30/iOS-CoreAnimation-%E4%B8%89-%E4%B9%8BCAAnimation/"/>
    <id>http://hmttommy.com/2015/10/30/iOS-CoreAnimation-三-之CAAnimation/</id>
    <published>2015-10-30T10:00:23.000Z</published>
    <updated>2015-10-30T10:00:23.000Z</updated>
    <content type="html"><![CDATA[<p>title: iOS CoreAnimation(三)之CAAnimation<br>date: 2015-6-03 15:39:33<br>categories: CoreAnimation </p>
<h2 id="tags_3A_CAAnimation_CAMediaTiming"><a href="#tags_3A_CAAnimation_CAMediaTiming" class="headerlink" title="tags: CAAnimation CAMediaTiming"></a>tags: CAAnimation CAMediaTiming</h2><p>原定第三篇直接介绍<code>CAPropertyAnimation</code>的两个子类,想想还是回过头来梳理一下<font color="#ce1f48"><code>CAAnimation</code></font>这个父类,比如<code>CABasicAnimation</code>属于他自己的只有3个property,其他都是继承来的.不过就算是<code>CAAnimation</code>,它自身的property还是用的不多,像我们定义动画常常设置的时间property<code>duration</code>,<code>beginTime</code>,<code>repeatCount</code>等都在协议<font color="#ce1f48"><code>CAMediaTiming</code></font>&gt;中…  </p>
<h3 id="CAAnimation_Property"><a href="#CAAnimation_Property" class="headerlink" title="CAAnimation Property"></a><font color="#ce1f48">CAAnimation Property</font></h3><p><code>removedOnCompletion</code>:设置是否动画完成后，动画效果从设置的layer上移除。默认为YES<br><code>timingFunction</code>:用于变化起点和终点之间的插值计算,形象点说它决定了动画运行的节奏,比如是均匀变化(相同时间变化量相同)还是先快后慢,先慢后快还是先慢再快再慢.(类似于第一章最后介绍的那些枚举)LZ数学略渣,这里引用一段话(<a href="http://geeklu.com/2012/09/animation-in-ios/" target="_blank" rel="external">http://geeklu.com/2012/09/animation-in-ios/</a>)<br><strong>时间函数是使用的一段函数来描述的,横座标是时间t取值范围是0.0-1.0,纵座标是变化量x(t)也是取值范围也是0.0-1.0 假设有一个动画,duration是8秒,变化值的起点是a终点是b(假设是透明度),那么在4秒处的值是多少呢？ 可以通过计算为 a + x(4/8) <em> (b-a), 为什么这么计算呢？讲实现的时间映射到单位值的时候4秒相对于总时间8秒就是0.5然后可以得到0.5的时候单位变化量是 x(0.5), x(0.5)/1 = 实际变化量/(b-a), 其中b-a为总变化量,所以实际变化量就是x(0.5) </em> (b-a) ,最后4秒时的值就是 a + x(0.5) * (b-a),所以计算的本质是映射.<br>Timing Function对应的类是<font color="#ce1f48"><code>CAMediaTimingFunction</code></font>,它提供了两种获得时间函数的方式,一种是使用预定义的五种时间函数,一种是通过给点两个控制点得到一个时间函数</strong><br>系统给的最熟悉的就是<code>Linear</code>了,匀速…<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kCAMediaTimingFunctionLinear, </span><br><span class="line">kCAMediaTimingFunctionEaseIn, </span><br><span class="line">kCAMediaTimingFunctionEaseOut, </span><br><span class="line">kCAMediaTimingFunctionEaseInEaseOut, </span><br><span class="line">kCAMediaTimingFunctionDefault. </span><br><span class="line">```    </span><br><span class="line">自定义的则是下面2个方法:(贝塞尔曲线什么的,不太懂...)  </span><br><span class="line"><span class="comment">&lt;!--more--&gt;</span></span><br></pre></td></tr></table></figure></p>
<pre><code>/* Creates a timing function modelled on a cubic Bezier curve. The end
 * points of the curve are at (0,0) and (1,1), the two points &apos;c1&apos; and
 * &apos;c2&apos; defined by the class instance are the control points. Thus the
 * points defining the Bezier curve are: &apos;[(0,0), c1, c2, (1,1)]&apos; */

public init(controlPoints c1x: Float, _ c1y: Float, _ c2x: Float, _ c2y: Float)

/* &apos;idx&apos; is a value from 0 to 3 inclusive. */
 public func getControlPointAtIndex(idx: Int, values ptr: UnsafeMutablePointer&lt;Float&gt;)
</code></pre><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;/br&gt;  </span><br><span class="line">### &lt;font color=<span class="string">"#ce1f48"</span>&gt;CAMediaTiming Property&lt;/font&gt;    </span><br><span class="line"><span class="escape">`d</span>uration<span class="escape">`:</span>动画持续时间(最熟悉没有之一...),默认是<span class="number">0</span>,但这不意味着动画时长为<span class="number">0</span>秒,为<span class="number">0.25</span>  </span><br><span class="line"><span class="escape">`b</span>eginTime<span class="escape">`:</span>指定动画开始时间。从开始指定延迟几秒执行的话，请设置为「CACurrentMediaTime() + 秒数」的形式.  </span><br><span class="line"><span class="escape">`t</span>imeOffset<span class="escape">`:</span>我理解为时间的偏移量,比如一个duration为<span class="number">5</span>秒的动画,将timeOffset设置为<span class="number">2</span>,那么动画的运行是<span class="number">2</span>s-&gt;<span class="number">5</span>s-&gt;<span class="number">0</span>s-&gt;<span class="number">2</span>s  </span><br><span class="line"><span class="escape">`s</span>peed<span class="escape">`:</span>时间加速..设置duration为<span class="number">3</span>秒，但是speed为<span class="number">2</span>，动画快速的执行了<span class="number">1.5</span>秒,speed越大则说明时间流逝速度越快,动画也越快  </span><br><span class="line"><span class="escape">`r</span>epeatCount<span class="escape">`:</span>代表动画重复的迭代次数,默认为<span class="number">0</span>,也并不意味为<span class="number">0</span>次,而是<span class="number">1</span>次  </span><br><span class="line"><span class="escape">`r</span>epeatDuration<span class="escape">`:</span>动画的重复时间(间隔),如果它小于动画的duration，那么动画就会提前结束  </span><br><span class="line"><span class="escape">`a</span>utoreverses(Bool)<span class="escape">`:</span>动画结束时是否执行逆动画,可以产生从初始值到最终值，并反过来回到初始值的动画,也就是这意味着动画发生了两次  </span><br><span class="line"><span class="escape">`f</span>illMode<span class="escape">`:</span>一般与<span class="escape">`r</span>emovedOnCompletion<span class="escape">`(</span>必须设置为<span class="literal">false</span>)一起用</span><br></pre></td></tr></table></figure>
<p>kCAFillModeRemoved  // 这个是默认值,也就是说当动画开始前和动画结束后,动画对layer都没有影响,动画结束后,layer会恢复到之前的状态<br>kCAFillModeForwards // 当动画结束后,layer会一直保持着动画最后的状态<br>kCAFillModeBackwards // 这个和kCAFillModeForwards是相对的,就是在动画开始前,你只要将动画加入了一个layer,layer便立即进入动画的初始状态并等待动画开始.你可以这样设定测试代码,将一个动画加入一个layer的时候延迟5秒执行.然后就会发现在动画没有开始的时候,只要动画被加入了layer,layer便处于动画初始状态<br>kCAFillModeBoth  // 理解了上面两个,这个就很好理解了,这个其实就是上面两个的合成.动画加入后开始之前,layer便处于动画初始状态,动画结束后layer保持动画最后的状态.<br>```  </p>
<p><strong>参考链接:</strong><br><a href="http://ronnqvi.st/controlling-animation-timing/" target="_blank" rel="external">Controlling Animation Timing</a><br><a href="https://zsisme.gitbooks.io/ios-/content/chapter9/the-cAMediaTiming-protocol.html" target="_blank" rel="external">CAMediaTiming</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>title: iOS CoreAnimation(三)之CAAnimation<br>date: 2015-6-03 15:39:33<br>categories: CoreAnimation </p>
<h2 id="tags_3A_CAAnimation_CAMedia]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS开发过程中的知识点总结(续)]]></title>
    <link href="http://hmttommy.com/2015/10/22/iOS%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-%E7%BB%AD/"/>
    <id>http://hmttommy.com/2015/10/22/iOS开发过程中的知识点总结-续/</id>
    <published>2015-10-22T03:24:15.000Z</published>
    <updated>2015-10-26T06:48:53.000Z</updated>
    <content type="html"><![CDATA[<p>之前在做项目的时候经常会遇到一些细小的知识点,不影响做项目的大方向,但确影响了很多细小的点..比如公式转换,汉字拼音,颜色转换等等,什么都涉及…上次写的还是在<code>CSDN</code>写blog时记录的:<a href="http://blog.csdn.net/hmt20130412/article/details/23975535" target="_blank" rel="external">iOS开发 容易犯错的知识点和不错的细小知识点(持续更新)</a>,现在换地方了,就不在接着原来的写了,重开一个,依旧持续更新,持续记录.  </p>
<h3 id="35-_u5F53_u4F60_u5411_u9879_u76EE_u4E2D_u6DFB_u52A0_u4E00_u4E2A_u6587_u4EF6_u5939_u65F6_2C_u5F80_u5F80_u4F1A_u9762_u5BF9Create_groups_u548CCreate_folder_references_u7684_u9009_u62E9"><a href="#35-_u5F53_u4F60_u5411_u9879_u76EE_u4E2D_u6DFB_u52A0_u4E00_u4E2A_u6587_u4EF6_u5939_u65F6_2C_u5F80_u5F80_u4F1A_u9762_u5BF9Create_groups_u548CCreate_folder_references_u7684_u9009_u62E9" class="headerlink" title="35.当你向项目中添加一个文件夹时,往往会面对Create groups和Create folder references的选择"></a><font color="#ce1f48">35.当你向项目中添加一个文件夹时,往往会面对<code>Create groups</code>和<code>Create folder references</code>的选择</font></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">前者Create groups <span class="keyword">for</span> any added folders  : 给任一你添加的文件创建一个组groups</span><br><span class="line">后者Create folder references <span class="keyword">for</span> any added folders  :给任一你添加的文件创建一个文件夹folder</span><br><span class="line">两的区别是：前者的文件夹是黄色的；后者的文件夹是蓝色的</span><br><span class="line">如果有一个info.h文件需要引用：前者直接导入import <span class="string">"info.h"</span>就可能使用；后者你需要import <span class="string">"文件夹名字/info.h"</span>才可能使用，否则编译时找不到文件info.h。</span><br><span class="line">```  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="preprocessor">### &lt;font color=<span class="string">"#ce1f48"</span>&gt;<span class="number">36.</span>Pointer is missing a nullability type specifier (__nonnull or __nullable)的解决方法:&lt;/font&gt;    </span></span><br><span class="line">首尾加入`NS_ASSUME_NONNULL_BEGIN`和`NS_ASSUME_NONNULL_END`  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="preprocessor">### &lt;font color=<span class="string">"#ce1f48"</span>&gt;<span class="number">37.U</span>IButton文本对齐问题&lt;/font&gt;    </span></span><br><span class="line">这里使用`button.titleLabel.textAlignment = NSTextAlignmentLeft;` 这行代码是没有效果的，这只是让标签中的文本左对齐，但</span><br><span class="line">并没有改变标签在按钮中的对齐方式。  </span><br><span class="line">所以，我们首先要使用`button.contentHorizontalAlignment = UIControlContentHorizontalAlignmentLeft;` 这行代码，把按钮的内容（控件）</span><br><span class="line">的对齐方式修改为水平左对齐，但是这们会紧紧靠着左边，不好看...  </span><br><span class="line">所以我们还可以修改属性：`button.titleEdgeInsets = UIEdgeInsetsMake(<span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>);`这行代码可以让按钮的内容（控件）距离左边<span class="number">10</span>个像素，这样就OK了  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="preprocessor">### &lt;font color=<span class="string">"#ce1f48"</span>&gt;<span class="number">38.</span>获取window的方法之前都是直接`[UIApplication sharedApplication].keyWindow;`&lt;/font&gt;    </span></span><br><span class="line">之后导入bug tags的时候提醒用比较严谨的获取方法：</span><br></pre></td></tr></table></figure>
<ul>
<li><p>(UIWindow <em>)lastWindow<br>{<br>  NSArray </em>windows = [UIApplication sharedApplication].windows;<br>  for(UIWindow *window in [windows reverseObjectEnumerator]) {</p>
<pre><code>if ([window isKindOfClass:[UIWindow class]] &amp;&amp;
    CGRectEqualToRect(window.bounds, [UIScreen mainScreen].bounds))

    return window;
</code></pre><p>  }</p>
<p>  return [UIApplication sharedApplication].keyWindow;<br>}</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--more--&gt;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### <span class="tag">&lt;<span class="title">font</span> <span class="attribute">color</span>=<span class="value">"#ce1f48"</span>&gt;</span>39.如果你觉得你开启太快,那么漂亮得LaunchImage还没怎么展示就跳过了.你可以在你的第一个加载页面中添加如下代码来延长LaunchImage的显示时间<span class="tag">&lt;/<span class="title">font</span>&gt;</span>  </span><br><span class="line">`NSThread.sleepForTimeInterval(3.0)//延长3秒`  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">### <span class="tag">&lt;<span class="title">font</span> <span class="attribute">color</span>=<span class="value">"#ce1f48"</span>&gt;</span>40.关闭键盘的自动联想和首字母大写功能<span class="tag">&lt;/<span class="title">font</span>&gt;</span>  </span><br><span class="line">`[_userNameTextField setAutocorrectionType:UITextAutocorrectionTypeNo];`  </span><br><span class="line">`[_userNameTextField setAutocapitalizationType:UITextAutocapitalizationTypeNone];`  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">### <span class="tag">&lt;<span class="title">font</span> <span class="attribute">color</span>=<span class="value">"#ce1f48"</span>&gt;</span>41.设置导航栏下方不显示内容(此时导航栏无透明度)<span class="tag">&lt;/<span class="title">font</span>&gt;</span>  </span><br><span class="line">`self.extendedLayoutIncludesOpaqueBars = YES;`  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">### <span class="tag">&lt;<span class="title">font</span> <span class="attribute">color</span>=<span class="value">"#ce1f48"</span>&gt;</span>42.监测键盘通知时,发送多次的解决情况<span class="tag">&lt;/<span class="title">font</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>typedef NS_ENUM(NSInteger, KeyBoardAction) {<br>    KeyBoardActionShow = 0,<br>    KeyBoardActionHide = 1<br>}</p>
<p>self.action = 0;<br>// Do any additional setup after loading the view, typically from a nib.<br>[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(show) name:UIKeyboardWillShowNotification object:nil];<br>[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(hide) name:UIKeyboardWillHideNotification object:nil];</p>
<ul>
<li><p>(void)show {<br>  // 防止按home键退出后台再返回前台发送的多余通知<br>  if ([UIApplication sharedApplication].applicationState != UIApplicationStateActive) {</p>
<pre><code>return;
</code></pre><p>  }<br>  if (_action == KeyBoardActionShow) {</p>
<pre><code>NSLog(@&quot; name = %s&quot;,__FUNCTION__);
_action = KeyBoardActionHide;
</code></pre><p>  }<br>}</p>
</li>
<li><p>(void)hide {<br>  if ([UIApplication sharedApplication].applicationState != UIApplicationStateActive) {</p>
<pre><code>return;
</code></pre><p>  }<br>  if (_action == KeyBoardActionHide) {</p>
<pre><code>NSLog(@&quot; name = %s&quot;,__FUNCTION__);
_action = KeyBoardActionShow;
</code></pre><p>  }<br>}</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">  </span><br><span class="line">### <span class="tag">&lt;<span class="title">font</span> <span class="attribute">color</span>=<span class="value">"#ce1f48"</span>&gt;</span>43.http/https请求获取cookie的问题<span class="tag">&lt;/<span class="title">font</span>&gt;</span>  </span><br><span class="line">项目需要获取cookie,但是网上找的获取cookie的方法:</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>NSHTTPCookieStorage <em>cookieJar = [NSHTTPCookieStorage sharedHTTPCookieStorage];<br>for (NSHTTPCookie </em>cookie in [cookieJar cookies]) {<br>   NSLog(@”%@”, cookie);<br>}<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">无法获取完整的cookie,打印出来的只有一小部分....实际获取的方法是:  </span><br><span class="line">`<span class="built_in">NSString</span> *cookieString = [[request<span class="variable">.requestOperation</span><span class="variable">.response</span> allHeaderFields ] valueForKey:<span class="string">@"Set-Cookie"</span>];`  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="preprocessor">### <span class="title">&lt;font color="#ce1f48"&gt;</span>44.金融产品的金额形式变化<span class="title">&lt;/font&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>// 30000000 - &gt; 30,000,000</p>
<ul>
<li>(NSString <em>)addMarkToString {<br>  NSNumberFormatter</em> numberFormatter = [[NSNumberFormatter alloc] init];<br>  [numberFormatter setFormatterBehavior: NSNumberFormatterBehavior10_4];<br>  [numberFormatter setNumberStyle: NSNumberFormatterDecimalStyle];<br>  NSString *numberString = [numberFormatter stringFromNumber: [NSNumber numberWithInteger: self.intValue]];<br>  return numberString;<br>}</li>
</ul>
<p>+(NSString <em>)countNumAndChangeformat:(CGFloat)num<br>{<br>    NSNumberFormatter </em>numberFormatter = [[NSNumberFormatter alloc] init] ;<br>    [numberFormatter setPositiveFormat:@”###,##0.00;”];<br>    NSString *formattedNumberString = [numberFormatter stringFromNumber:[NSNumber numberWithDouble:num]];<br>    return formattedNumberString;<br>}<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">  </span><br><span class="line">### <span class="tag">&lt;<span class="title">font</span> <span class="attribute">color</span>=<span class="value">"#ce1f48"</span>&gt;</span>44.iOS中使用blend改变图片颜色<span class="tag">&lt;/<span class="title">font</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>// UIImage Category</p>
<ul>
<li><p>(UIImage <em>) imageWithTintColor:(UIColor </em>)tintColor blendMode:(CGBlendMode)blendMode<br>{<br>  //We want to keep alpha, set opaque to NO; Use 0.0f for scale to use the scale factor of the device’s main screen.<br>  UIGraphicsBeginImageContextWithOptions(self.size, NO, 0.0f);<br>  [tintColor setFill];<br>  CGRect bounds = CGRectMake(0, 0, self.size.width, self.size.height);<br>  UIRectFill(bounds);</p>
<p>  //Draw the tinted image in context<br>  [self drawInRect:bounds blendMode:blendMode alpha:1.0f];</p>
<p>  if (blendMode != kCGBlendModeDestinationIn) {</p>
<pre><code>[self drawInRect:bounds blendMode:kCGBlendModeDestinationIn alpha:1.0f];
</code></pre><p>  }</p>
<p>  UIImage *tintedImage = UIGraphicsGetImageFromCurrentImageContext();<br>  UIGraphicsEndImageContext();</p>
<p>  return tintedImage;<br>}</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">喵神有篇文章讲这个的-&gt;[<span class="link_label">iOS中使用blend改变图片颜色</span>](<span class="link_url">http://www.onevcat.com/2013/04/using-blending-in-ios/</span>)  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="header">### &lt;font color="#ce1f48"&gt;44.UIColor 转 UIImage&lt;/font&gt;</span></span><br></pre></td></tr></table></figure>
<p>  func createImageWithColor() -&gt; UIImage {</p>
<pre><code>let rect = CGRectMake(0.0, 0.0, 1.0, 1.0)
UIGraphicsBeginImageContext(rect.size)
let context = UIGraphicsGetCurrentContext()
CGContextSetFillColorWithColor(context, self.CGColor)
CGContextFillRect(context, rect)
let theImage = UIGraphicsGetImageFromCurrentImageContext()
return theImage
</code></pre><p>  }</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">  </span><br><span class="line">### <span class="tag">&lt;<span class="title">font</span> <span class="attribute">color</span>=<span class="value">"#ce1f48"</span>&gt;</span>45.验证码button速写<span class="tag">&lt;/<span class="title">font</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>// UIButton Category</p>
<ul>
<li>(void)startTimeAtCodeButton {<br>  __block int timeout = 60; //倒计时时间<br>  dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);<br>  dispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0,queue);<br>  dispatch_source_set_timer(_timer,dispatch_walltime(NULL, 0),1.0*NSEC_PER_SEC, 0); //每秒执行<br>  dispatch_source_set_event_handler(_timer, ^{<pre><code>if(timeout&lt;=0){ //倒计时结束，关闭
    dispatch_source_cancel(_timer);
    dispatch_async(dispatch_get_main_queue(), ^{
        //设置界面的按钮显示 根据自己需求设置
        [self setTitle:@&quot;发送验证码&quot; forState:UIControlStateNormal];
        [self setTitleColor:k_Color_FF9331 forState:UIControlStateNormal];
        self.contentMode = UIViewContentModeLeft;
        self.userInteractionEnabled = YES;
    });
}else{
    //            int minutes = timeout / 60;
    int seconds = timeout % 61;
    NSString *strTime = [NSString stringWithFormat:@&quot;%.2d&quot;, seconds];
    dispatch_async(dispatch_get_main_queue(), ^{
        //设置界面的按钮显示 根据自己需求设置
        [self setTitle:[NSString stringWithFormat:@&quot;再次发送%@秒&quot;,strTime] forState:UIControlStateNormal];
        [self setTitleColor:k_Color_cccccc forState:UIControlStateNormal];
        self.contentMode = UIViewContentModeCenter;
        self.userInteractionEnabled = NO;
    });
    timeout--;
}
</code></pre>  });<br>  dispatch_resume(_timer);<br>}<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">  </span><br><span class="line">### <span class="tag">&lt;<span class="title">font</span> <span class="attribute">color</span>=<span class="value">"#ce1f48"</span>&gt;</span>45.NSDate的各种转换<span class="tag">&lt;/<span class="title">font</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>//  时间戳转化为是刚刚、几分钟前、几小时前、几天前等(与当前时间相比)</p>
<ul>
<li>(NSString <em>)currentDateWithRerence:(NSTimeInterval)timeStamp {<br>  NSDate </em>confromTimesp = [NSDate dateWithTimeIntervalSince1970:timeStamp];<br>  return [[NSDate date] prettyDateWithReference:confromTimesp];<br>}</li>
</ul>
<p>//  时间转化为是刚刚、几分钟前、几小时前、几天前等(自定义时间相比)</p>
<ul>
<li><p>(NSString <em>)prettyDateWithReference:(NSDate </em>)reference {<br>  NSString *suffix = @”前”;</p>
<p>  float different = [reference timeIntervalSinceDate:self];<br>  if (different &lt; 0) {</p>
<pre><code>different = -different;
suffix = @&quot;前&quot;;
</code></pre><p>  }</p>
<p>  // days = different / (24 <em> 60 </em> 60), take the floor value<br>  float dayDifferent = floor(different / 86400);</p>
<p>  int days   = (int)dayDifferent;<br>  int weeks  = (int)ceil(dayDifferent / 7);<br>  int months = (int)ceil(dayDifferent / 30);<br>  int years  = (int)ceil(dayDifferent / 365);</p>
<p>  // It belongs to today<br>  if (dayDifferent &lt;= 0) {</p>
<pre><code>// lower than 60 seconds
if (different &lt; 60) {
    return @&quot;刚刚&quot;;
}

// lower than 120 seconds =&gt; one minute and lower than 60 seconds
if (different &lt; 120) {
    return [NSString stringWithFormat:@&quot;1分钟%@&quot;, suffix];
}

// lower than 60 minutes
if (different &lt; 66 * 60) {
    return [NSString stringWithFormat:@&quot;%d分钟%@&quot;, (int)floor(different / 60), suffix];
}

// lower than 60 * 2 minutes =&gt; one hour and lower than 60 minutes
if (different &lt; 7200) {
    return [NSString stringWithFormat:@&quot;1小时%@&quot;, suffix];
}

// lower than one day
if (different &lt; 86400) {
    return [NSString stringWithFormat:@&quot;%d小时%@&quot;, (int)floor(different / 3600), suffix];
}
</code></pre><p>  }<br>  // lower than one week<br>  else if (days &lt; 7) {</p>
<pre><code>return [NSString stringWithFormat:@&quot;%d天%@%@&quot;, days, days == 1 ? @&quot;&quot; : @&quot;&quot;, suffix];
</code></pre><p>  }<br>  // lager than one week but lower than a month<br>  else if (weeks &lt; 4) {</p>
<pre><code>return [NSString stringWithFormat:@&quot;%d周%@%@&quot;, weeks, weeks == 1 ? @&quot;&quot; : @&quot;&quot;, suffix];
</code></pre><p>  }<br>  // lager than a month and lower than a year<br>  else if (months &lt; 12) {</p>
<pre><code>return [NSString stringWithFormat:@&quot;%d月%@%@&quot;, months, months == 1 ? @&quot;&quot; : @&quot;&quot;, suffix];
</code></pre><p>  }<br>  // lager than a year<br>  else {  </p>
<pre><code>return [NSString stringWithFormat:@&quot;%d年%@%@&quot;, years, years == 1 ? @&quot;&quot; : @&quot;&quot;, suffix];
</code></pre><p>  }  </p>
<p>  return self.description;<br>}</p>
</li>
</ul>
<p>//  时间戳转化为当前时间</p>
<ul>
<li>(NSString <em>)timeIntervalToNSDate:(NSTimeInterval)time {<br>  //因为时差问题要加8小时 == 28800 sec<br>  NSDate </em>detaildate=[NSDate dateWithTimeIntervalSince1970:(time  )];<br>  //实例化一个NSDateFormatter对象<br>  NSDateFormatter <em>dateFormatter = [[NSDateFormatter alloc] init];<br>  //设定时间格式,这里可以设置成自己需要的格式<br>  [dateFormatter setDateFormat:@”yyyy-MM-dd”];<br>  NSString </em>currentDateStr = [dateFormatter stringFromDate: detaildate];<br>  return currentDateStr;<br>}<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="xml">### <span class="tag">&lt;<span class="title">font</span> <span class="attribute">color</span>=<span class="value">"#ce1f48"</span>&gt;</span>46.tableView的分割线左边不到头的问题<span class="tag">&lt;/<span class="title">font</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>tableView.separatorInset = UIEdgeInsetsZero<br>tableView.layoutMargins = UIEdgeInsetsZero<br>    func tableView(tableView: UITableView, willDisplayCell cell: UITableViewCell, forRowAtIndexPath indexPath: NSIndexPath) {<br>        cell.separatorInset = UIEdgeInsetsZero<br>        cell.layoutMargins = UIEdgeInsetsZero<br>    }<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="cpp">  </span><br><span class="line"><span class="preprocessor">### &lt;font color=<span class="string">"#ce1f48"</span>&gt;<span class="number">47.</span>实现UITableView Plain SectionView和table不停留一起滑动&lt;/font&gt;  </span></span><br><span class="line"> <span class="number">1</span>） 这个代码是通过scroll偏移量来监听和改变你的tableview的contentInset 可见很不好（试试就知道） X</span></span><br></pre></td></tr></table></figure></p>
<p>   // 去掉UItableview headerview黏性(sticky)</p>
<pre><code>- (void)scrollViewDidScroll:(UIScrollView *)scrollView
{
    CGFloat sectionHeaderHeight = 40;(你的section高度)
    if (scrollView.contentOffset.y&lt;=sectionHeaderHeight&amp;&amp;scrollView.contentOffset.y&gt;=0) {
        scrollView.contentInset = UIEdgeInsetsMake(-scrollView.contentOffset.y, 0, 0, 0);
    }
    else if (scrollView.contentOffset.y&gt;=sectionHeaderHeight) {
        scrollView.contentInset = UIEdgeInsetsMake(-sectionHeaderHeight, 0, 0, 0);
    }
}
</code></pre><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2）和第一个没太大本质区别，在自定义headSectionView中重写setframe方法来重载table的section[<span class="link_label">TablePlainSectionView</span>](<span class="link_url">https://github.com/rongtian/TablePlainSectionView</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>(void)setFrame:(CGRect)frame{<br>  CGRect sectionRect = [self.tableView rectForSection:self.section];<br>  CGRect newFrame = CGRectMake(CGRectGetMinX(frame), CGRectGetMinY(sectionRect), CGRectGetWidth(frame), CGRectGetHeight(frame)); [super setFrame:newFrame];<br>}<br>```  </li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前在做项目的时候经常会遇到一些细小的知识点,不影响做项目的大方向,但确影响了很多细小的点..比如公式转换,汉字拼音,颜色转换等等,什么都涉及…上次写的还是在<code>CSDN</code>写blog时记录的:<a href="http://blog.csdn.net/h]]>
    </summary>
    
      <category term="小技巧" scheme="http://hmttommy.com/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
      <category term="资料" scheme="http://hmttommy.com/categories/%E8%B5%84%E6%96%99/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://hmttommy.com/2015/10/16/xctool-xcodebuild%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85%E5%82%BB%E7%93%9C%E5%BC%8F%E6%95%99%E7%A8%8B/"/>
    <id>http://hmttommy.com/2015/10/16/xctool-xcodebuild自动打包傻瓜式教程/</id>
    <published>2015-10-16T10:08:59.000Z</published>
    <updated>2015-10-16T10:08:59.000Z</updated>
    <content type="html"><![CDATA[<p>title: xctool+xcodebuild自动打包傻瓜式教程<br>date: 2015-10-16 16:20:54<br>categories: 工具 </p>
<h2 id="tags_3A_xctool"><a href="#tags_3A_xctool" class="headerlink" title="tags: xctool"></a>tags: xctool </h2><p>以前打包提测觉得没什么,<code>选证书-选profile-选xxx-选xxxxx</code>,但一天打N次包后就有那么点厌烦了…俗话说:不会”偷懒”的攻城狮不是好的攻城狮,我知道很久之前就已经有自动打包(貌似略土,那就自动化的持续集成?随意了…),那时是坏的懒性主导,正好昨天逛微博有篇文章讲<code>XCToool自动打包</code>的,就决定亲自做一下,折腾了1小时后,总算OK了…在此记录一下.<br>(PS:为什么叫傻瓜教程呢?因为LZ略蠢,shell命令也不太懂,查了很多资料+波波的教导,一步一步的才调好)    </p>
<h2 id="u5B89_u88C5"><a href="#u5B89_u88C5" class="headerlink" title="安装"></a><font color="IndianRed">安装</font></h2><p>xctool的<a href="https://github.com/facebook/xctool" target="_blank" rel="external">Github地址</a>,当然最好是通过<a href="http://brew.sh/index_zh-cn.html" target="_blank" rel="external">Homebrew</a>来安装,简单方便.<br><code>brew update</code><br><code>brew install xctool</code><br>等等就OK了.  </p>
<h2 id="u76F4_u63A5_u53EF_u6267_u884C_u7684_u6587_u672C"><a href="#u76F4_u63A5_u53EF_u6267_u884C_u7684_u6587_u672C" class="headerlink" title="直接可执行的文本"></a><font color="IndianRed">直接可执行的文本</font></h2><pre><code>#!/bin/sh
set -e
cd `dirname $0`


SCHEME_NAME=Wecube
WORKSPACE_PATH=/Users/humingtao/Desktop/Wecube/Wecube.xcworkspace
PROFILE_NAME=&apos;com.shuabao.wecube.production&apos;


TIME_STAMP=`date &quot;+%Y%m%d%H&quot;`
BUILD_TIME=$(date +%Y%m%d%H%M)
ArchivePath=/Users/humingtao/Desktop/AutoIpa/ArchivePath/${SCHEME_NAME}.xcarchive
PacketName=/Users/humingtao/Desktop/AutoIpa/ipa/${SCHEME_NAME}_${BUILD_TIME}.ipa


# clean
xctool -workspace ${WORKSPACE_PATH} -scheme ${SCHEME_NAME} clean

#archive
xctool -workspace ${WORKSPACE_PATH} -scheme ${SCHEME_NAME} archive -archivePath ${ArchivePath}

#export
xcodebuild -exportArchive -exportFormat IPA -archivePath ${ArchivePath} -exportPath ${PacketName} -exportProvisioningProfile &quot;${PROFILE_NAME}&quot;
</code></pre><p><code>第一行</code>:指次脚本使用/bin/sh来解释执行<br><code>第二行</code>:出错立刻终止<br><code>第三行</code>:cd 当前目录<br><code>第六行</code>:你工程的Scheme名,一般就是xcode终止运行按钮旁边的那个,还不知道的话自行谷歌..<br><code>第七行</code>:如果你的工程接入了cocoapods,那么后缀就是xcworkspace,否则就是常规后缀(路径我是绝对路径,这个梗后面说)<br><code>第八行</code>:profile…都懂吧?发布的配置概要文件,写上对应的名字就行了<br><code>第十二行</code>:通过时间来命令ipa包的名字<br><code>第十三行</code>:存放打包过程中生成的序列化文件的文件夹(AutoIpa是我在desktop上建立的文件夹,ArchivePath会自动创建)<br><code>第十四行</code>:最后生成的ipa文件所在路径(AutoIpa是我在desktop上建立的文件夹,ipa文件夹也要自己创建)<br><code>剩下的</code>:就是xcodebuild的命令,不需要懂,前面的参数填好就OK  </p>
<h2 id="u6CE8_u610F"><a href="#u6CE8_u610F" class="headerlink" title="注意"></a><font color="IndianRed">注意</font></h2><ul>
<li>LZ用的是绝对路径,因为我没有把脚本和生成ipa的文件夹直接放到工程里面…这个根据自身情况来弄,我喜欢什么都往桌面放…  </li>
<li>文本的后缀名用.sh,直接扔终端回车就行,如果出现<code>Permission denied</code>,那么就修改一下文件权限:chmod 777 xxxx.sh 就行了  </li>
</ul>
<p>附上打包成功的图:<br><img src="http://7qn7zn.com1.z0.glb.clouddn.com/xctool_success.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>title: xctool+xcodebuild自动打包傻瓜式教程<br>date: 2015-10-16 16:20:54<br>categories: 工具 </p>
<h2 id="tags_3A_xctool"><a href="#tags_3A_xctool" c]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Star Github share]]></title>
    <link href="http://hmttommy.com/2015/10/12/Star-Github-share/"/>
    <id>http://hmttommy.com/2015/10/12/Star-Github-share/</id>
    <published>2015-10-12T09:11:02.000Z</published>
    <updated>2016-01-20T01:32:42.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u76EE_u5F55"><a href="#u76EE_u5F55" class="headerlink" title="目录"></a><font color="IndianRed">目录</font></h2><ul>
<li><a href="/#foreword">前言</a>  </li>
<li><a href="/#all">总览/大集合</a>  </li>
<li><a href="/#network">网络请求Network</a>  </li>
<li><a href="/#datastore">数据存储</a>  </li>
<li><a href="/#image_sync_downloap">图片异步下载缓存</a>    </li>
<li><a href="/#json_model">json/HTML/XML&lt;-&gt;model</a>  </li>
<li><a href="/#framework">框架</a>  </li>
<li><a href="/#Functionalprogramming">Swift函数式编程</a>  </li>
<li><a href="/#UI总览">UI总览</a>  </li>
<li><a href="/#UIImagePickerController">UIImagePickerController/图片浏览</a>  </li>
<li><a href="/#UIScrollView">UIScrollView</a>  </li>
<li><a href="/#UILabel">UILabel</a>  </li>
<li><a href="/#UIButton">UIButton</a>  </li>
<li><a href="/#UITextField">UITextField</a>  </li>
<li><a href="/#UIImage/UIImageView">UIImage/UIImageView</a>    </li>
<li><a href="/#UITableView/UITableViewCell">UITableView/UITableViewCell</a>  </li>
<li><a href="/#UICollectionView">UICollectionView</a>  </li>
<li><a href="/#UITabBarViewController">UITabBarViewController</a>  </li>
<li><a href="/#UINavigationBar">UINavigationBar</a>  </li>
<li><a href="/#Left|Top_Menu">Left|Top_Menu</a></li>
<li><a href="/#Push/Present">Push/Present</a>  </li>
<li><a href="/#日历UI">日历UI</a>    </li>
<li><a href="/#UIWebView">UIWebView</a>  </li>
<li><a href="/#guide page">引导页/新手操作指示</a>  </li>
<li><a href="/#UI other">UI other 不知到咋分类了</a>  </li>
<li><a href="/#AutoLayout">AutoLayout</a>    </li>
<li><a href="/#Pop-up/Pop-down">Pop-up/Pop-down View</a>  </li>
<li><a href="/#refresh_up/down">下拉刷新和上拉加载</a>  </li>
<li><a href="/#animation">Animation</a>  </li>
<li><a href="/#chart_progress">图表/进度条/Loading</a>  </li>
<li><a href="/#coretext">CoreText</a>  </li>
<li><a href="/#Video">音频视频</a>  </li>
<li><a href="/#IM">IM</a>  </li>
<li><a href="/#GCD">GCD</a>    </li>
<li><a href="/#String">String/CGFloat/Int/Double</a>    </li>
<li><a href="/#Date">Date</a>  </li>
<li><a href="/#categories">Categories</a>  </li>
<li><a href="/#Tools">Tools</a>  </li>
<li><a href="/#unit testing">Unit Testing</a></li>
<li><a href="/#Reachability">网络状况监测</a>  </li>
<li><a href="/#keychain">keychain</a>  </li>
<li><a href="/#Xcode">Xcode 插件</a>  </li>
<li><a href="/#mac">mac 插件</a>  </li>
<li><a href="/#book">书籍</a>  </li>
<li><a href="/#otherCompany">他人推荐</a>  </li>
</ul>
<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a><a id="foreword"></a><font color="IndianRed">前言</font></h2><p> Github可说是全球最大的IT”交友约会”网站,各种各样牛逼的<code>open source code</code>,star!star!star!LZ逛github也有些时候了,经常会出现一个困惑,就是star了新的,很多以前star的一想不起名字,就很难找到,要一页一页的翻…想想,如果你star超过了50多页,每一次不得找死…之前我是用<code>Chrome</code>的收藏夹功能来区分,一段时间努力后,就成了下面这个样子:<br> <img src="http://7qn7zn.com1.z0.glb.clouddn.com/chrome%20github.png" alt=""><br> 还是比较方便的,起码完成了分类,只是没能加上自己收藏时对链接的注释(这样查找更快了),昨天朋友推荐了<a href="https://app.astralapp.com/" target="_blank" rel="external">Astral</a>,通过加标签的方式来实现分类,也很直观明了…那为什么LZ还要做这个整理呢?一是,能够分享出来;二是:可以自己无限的加入自己解释,更快的<code>天下Code,唯快不破</code>查找^_^!<br> <a id="more"></a>  </p>
<h2 id="u603B_u89C8/_u5927_u96C6_u5408"><a href="#u603B_u89C8/_u5927_u96C6_u5408" class="headerlink" title="总览/大集合"></a><a id="all"></a><font color="IndianRed">总览/大集合</font></h2><ul>
<li><a href="https://github.com/vsouza/awesome-ios" target="_blank" rel="external">vsouza/awesome-ios</a> (A curated list of awesome iOS ecosystem, including Objective-C and Swift Projects)    </li>
<li><a href="https://github.com/matteocrippa/awesome-swift#network" target="_blank" rel="external">matteocrippa/awesome-swift</a> (A collaborative list of awesome swift resources. Feel free to contribute!)  </li>
<li><a href="https://github.com/ipader/SwiftGuide" target="_blank" rel="external">ipader/SwiftGuide</a> (这份指南汇集了Swift语言主流学习资源，并以开发者的视角整理编排)  </li>
<li><a href="http://www.ioscookies.com/" target="_blank" rel="external">ioscookies</a> (国外收集的优秀的swift第三方库)  </li>
<li><a href="https://github.com/ibireme/YYKit" target="_blank" rel="external">YYKit</a> (涉及了图片下载,富文本,缓存等多个高性能开源库)  </li>
</ul>
<h2 id="u7F51_u7EDC_u8BF7_u6C42Network"><a href="#u7F51_u7EDC_u8BF7_u6C42Network" class="headerlink" title="网络请求Network"></a><a id="network"></a><font color="IndianRed">网络请求Network</font></h2><ul>
<li><a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="external">AFNetworking</a> (不解释了…都懂)  </li>
<li><a href="https://github.com/Alamofire/Alamofire" target="_blank" rel="external">Alamofire</a> (swift版本AFNetworking)  </li>
<li><a href="https://github.com/yuantiku/YTKNetwork" target="_blank" rel="external">YTKNetwork</a> (巧神团队封装了AFNetworking,本人现在的项目也在用)  </li>
<li><a href="https://github.com/johnlui/Pitaya" target="_blank" rel="external">Pitaya</a> (支持 Basic Authorization、SSL 钢钉、HTTP raw body / JSON body、快速文件上传等特性，并通过内置 JSONNeverDie 实现了对 JSON 的完全支持)  </li>
<li><a href="https://github.com/coderyi/NetworkEye" target="_blank" rel="external">NetworkEye</a> (可以监控App内HTTP请求并显示请求相关的详细信息，方便App开发的网络调试)  </li>
</ul>
<h2 id="u6570_u636E_u5B58_u50A8"><a href="#u6570_u636E_u5B58_u50A8" class="headerlink" title="数据存储"></a><a id="datastore"></a><font color="IndianRed">数据存储</font></h2><ul>
<li><a href="https://github.com/ccgus/fmdb" target="_blank" rel="external">fmdb</a> (不喜欢用coredata的人基本都会选它吧…)    </li>
<li><a href="https://github.com/yuantiku/YTKKeyValueStore" target="_blank" rel="external">YTKKeyValueStore</a> (依旧是巧神团队力作)  </li>
<li><a href="https://github.com/stephencelis/SQLite.swift" target="_blank" rel="external">SQLite.swift</a> (A type-safe, Swift-language layer over SQLite3.)  </li>
<li><a href="https://github.com/groue/GRDB.swift" target="_blank" rel="external">GRDB.swift</a> (让操作 SQLite 再简单一点，方便、实用)  </li>
<li><a href="https://github.com/realm/realm-cocoa" target="_blank" rel="external">realm-cocoa</a> (Realm主打移动数据库)  </li>
<li><a href="https://github.com/JohnEstropia/CoreStore" target="_blank" rel="external">CoreStore</a>  (Unleashing the real power of Core Data with the elegance and safety of Swift…没用过,看情形,swift有关coredata的开源库比sqlite的要多蛮多)  </li>
<li><a href="https://github.com/radex/SwiftyUserDefaults" target="_blank" rel="external">SwiftyUserDefaults</a> (见名知意)    </li>
<li><a href="https://github.com/Alecrim/AlecrimCoreData" target="_blank" rel="external">AlecrimCoreData_Swift</a>  </li>
<li><a href="https://github.com/nickoneill/Pantry" target="_blank" rel="external">Pantry</a> (可以持久化基础类型（String, Int, Float, Bool）变量值的类库。无论是退出应用还是重启设备，持久化设置过的变量可以被保存下来)  </li>
</ul>
<h2 id="u56FE_u7247_u5F02_u6B65_u4E0B_u8F7D_u7F13_u5B58"><a href="#u56FE_u7247_u5F02_u6B65_u4E0B_u8F7D_u7F13_u5B58" class="headerlink" title="图片异步下载缓存"></a><a id="image_sync_downloap"></a><font color="IndianRed">图片异步下载缓存</font></h2><ul>
<li><a href="https://github.com/rs/SDWebImage" target="_blank" rel="external">SDWebImage</a> (这个也不解释…源码很值得研究)    </li>
<li><a href="https://github.com/pinterest/PINRemoteImage" target="_blank" rel="external">PINRemoteImage</a>  </li>
<li><a href="https://github.com/onevcat/Kingfisher" target="_blank" rel="external">Kingfisher</a> (喵神作品,This project is heavily inspired by the popular SDWebImage)  </li>
<li><a href="https://github.com/ibireme/YYWebImage" target="_blank" rel="external">YYWebImage</a> (支持 APNG、WebP、GIF 动图的异步加载与播放、编码与解码，支持渐进式图像加载)  </li>
</ul>
<h2 id="json/HTML/XML_26lt_3B-_26gt_3Bmodel"><a href="#json/HTML/XML_26lt_3B-_26gt_3Bmodel" class="headerlink" title="json/HTML/XML&lt;-&gt;model"></a><a id="json_model"></a><font color="IndianRed">json/HTML/XML&lt;-&gt;model</font></h2><ul>
<li><a href="https://github.com/icanzilb/JSONModel" target="_blank" rel="external">JSONModel</a> (可以好好研究下源码,LZ貌似还没在项目中用过)  </li>
<li><a href="https://github.com/CoderMJLee/MJExtension" target="_blank" rel="external">MJExtension</a> (小码哥…)  </li>
<li><a href="https://github.com/mantle/mantle" target="_blank" rel="external">Mantle</a>  </li>
<li><a href="https://github.com/SwiftyJSON/SwiftyJSON" target="_blank" rel="external">SwiftyJSON</a> (The better way to deal with JSON data in Swift)  </li>
<li><a href="https://github.com/johnlui/JSONNeverDie" target="_blank" rel="external">JSONNeverDie</a> (Auto reflection tool from JSON to Model, user friendly JSON encoder / decoder, aims to never die)  </li>
<li><a href="https://github.com/matthewcheok/JSONCodable" target="_blank" rel="external">JSONCodable</a> (Hassle-free JSON encoding and decoding in Swift)  </li>
<li><a href="https://github.com/Hearst-DD/ObjectMapper" target="_blank" rel="external">ObjectMapper</a> (Simple JSON Object mapping written in Swift)  </li>
<li><a href="https://github.com/thoughtbot/Argo" target="_blank" rel="external">Argo</a> (类似楼上,二选其一)  </li>
<li><a href="https://github.com/ibireme/YYModel" target="_blank" rel="external">YYModel</a> (高性能,刚出不久,大家可以尝试一下,里面还有各个json-model库的性能测评)    </li>
<li><a href="https://github.com/honghaoz/Ji" target="_blank" rel="external">Ji</a> (Ji (戟) is an XML/HTML parser for Swift)  </li>
</ul>
<h2 id="u51FD_u6570_u54CD_u5E94_u5F0F_u7F16_u7A0B_u6846_u67B6"><a href="#u51FD_u6570_u54CD_u5E94_u5F0F_u7F16_u7A0B_u6846_u67B6" class="headerlink" title="函数响应式编程框架"></a><a id="framework"></a><font color="IndianRed">函数响应式编程框架</font></h2><ul>
<li><a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="external">ReactiveCocoa</a>  </li>
<li><a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="external">RxSwift</a>  </li>
<li><a href="https://github.com/mxcl/PromiseKit" target="_blank" rel="external">PromiseKit_Swift</a>  </li>
<li><a href="https://github.com/JensRavens/Interstellar" target="_blank" rel="external">Interstellar_Swift</a> (极简的 FRP)  </li>
<li><a href="https://github.com/SwiftBond/Bond" target="_blank" rel="external">Bond_Swift</a> (基于KVO)  </li>
<li><a href="https://github.com/slazyk/Observable-Swift" target="_blank" rel="external">Observable_Swift</a> (KVO for Swift - Value Observing and Events)  </li>
</ul>
<h2 id="Swift_u51FD_u6570_u5F0F_u7F16_u7A0B"><a href="#Swift_u51FD_u6570_u5F0F_u7F16_u7A0B" class="headerlink" title="Swift函数式编程"></a><a id="Functionalprogramming"></a><font color="IndianRed">Swift函数式编程</font></h2><ul>
<li><a href="https://github.com/ankurp/Dollar.swift" target="_blank" rel="external">Dollar.swift</a> (提供了有用的函数式编程辅助方法，无需扩展任何内置对象。Dollar类似于Lo-Dash或者Javascript中的Underscore。)   </li>
<li><a href="https://github.com/typelift/Swiftz" target="_blank" rel="external">Swiftz</a>    </li>
</ul>
<h2 id="UI_u603B_u89C8"><a href="#UI_u603B_u89C8" class="headerlink" title="UI总览"></a><a id="UI总览"></a><font color="IndianRed">UI总览</font></h2><ul>
<li><a href="https://github.com/cjwirth/awesome-ios-ui" target="_blank" rel="external">awesome-ios-ui</a>  </li>
<li><a href="https://github.com/Grouper/FlatUIKit" target="_blank" rel="external">FlatUIKit</a> (超喜欢这样的风格,强烈推荐)  </li>
<li><a href="https://github.com/fpt-software/Material-Controls-For-iOS" target="_blank" rel="external">Material-Controls-For-iOS</a>  </li>
<li><a href="https://github.com/nicklockwood/iCarousel" target="_blank" rel="external">iCarousel</a> (A simple, highly customisable, data-driven 3D carousel for iOS and Mac OS)  </li>
</ul>
<h2 id="UIImagePickerController/_u56FE_u7247_u6D4F_u89C8"><a href="#UIImagePickerController/_u56FE_u7247_u6D4F_u89C8" class="headerlink" title="UIImagePickerController/图片浏览"></a><a id="UIImagePickerController"></a><font color="IndianRed">UIImagePickerController/图片浏览</font></h2><ul>
<li><a href="https://github.com/MakeZL/ZLPhotoLib" target="_blank" rel="external">ZLPhotoLib</a> (LZ项目中在用的,使用很方便)  </li>
<li><a href="https://github.com/heroims/ZYQAssetPickerController" target="_blank" rel="external">ZYQAssetPickerController</a>  </li>
<li><a href="https://github.com/uzysjung/UzysAssetsPickerController" target="_blank" rel="external">UzysAssetsPickerController</a>  </li>
<li><a href="https://github.com/larcus94/ImagePickerSheetController" target="_blank" rel="external">ImagePickerSheetController</a>  </li>
<li><a href="https://github.com/MakeZL/MLSwiftBasic" target="_blank" rel="external">MLSwiftBasic</a>  </li>
<li><a href="https://github.com/CharlinFeng/PhotoBrowser" target="_blank" rel="external">PhotoBrowser</a>  </li>
<li><a href="https://github.com/EddyBorja/EBPhotoPages" target="_blank" rel="external">EBPhotoPages</a> (A photo gallery for iOS with a modern feature set. Similar features as the Facebook photo browser.)  </li>
<li><a href="https://github.com/suzuki-0000/SKPhotoBrowser" target="_blank" rel="external">SKPhotoBrowser_swift</a> (Simple PhotoBrowser/Viewer inspired by facebook, twitter photo browsers written by swift2.0)    </li>
<li><a href="https://github.com/AlexLittlejohn/ALCameraViewController" target="_blank" rel="external">ALCameraViewController</a> (含可定制照片选择器，图片简单裁切功能)  </li>
<li><a href="https://github.com/MailOnline/ImageViewer" target="_blank" rel="external">ImageViewer</a> (图片全屏预览组件及类库)    </li>
<li><a href="https://github.com/ideaismobile/IDMPhotoBrowser" target="_blank" rel="external">IDMPhotoBrowser</a> (功能比较完善的“图片浏览器”)  </li>
</ul>
<h2 id="UIScrollView"><a href="#UIScrollView" class="headerlink" title="UIScrollView"></a><a id="UIScrollView"></a><font color="IndianRed">UIScrollView</font></h2><ul>
<li><a href="https://github.com/adad184/XXPagingScrollView" target="_blank" rel="external">XXPagingScrollView</a> (Paged scrollView with custom paging width)    </li>
<li><a href="https://github.com/HAHAKea/HACursor" target="_blank" rel="external">HACursor</a> (是一个对横向ScrollView中的视图进行管理的UI控件。只要几行代码就可以集成类似于网易新闻对主题页面进行排序，删除操作的功能)  </li>
<li><a href="https://github.com/devgj/GJAutoCycleScrollView" target="_blank" rel="external">GJAutoCycleScrollView</a> (一个自动循环滚动的滚动视图。只需要两张图片循环利用, 史上性能最佳。 支持网络图片)   </li>
<li><a href="https://github.com/gsdios/SDCycleScrollView" target="_blank" rel="external">SDCycleScrollView</a> (无限循环图片轮播器)  </li>
<li><a href="https://github.com/pixyzehn/MediumScrollFullScreen" target="_blank" rel="external">MediumScrollFullScreen</a> (滚动的时候隐藏导航栏和底部栏)  </li>
<li><a href="https://github.com/SergioChan/SCNavigationControlCenter" target="_blank" rel="external">SCNavigationControlCenter</a> (类似于iOS9之后双击home出现的界面)  </li>
</ul>
<h2 id="UILabel"><a href="#UILabel" class="headerlink" title="UILabel"></a><a id="UILabel"></a><font color="IndianRed">UILabel</font></h2><ul>
<li><a href="https://github.com/lexrus/LTMorphingLabel" target="_blank" rel="external">LTMorphingLabel</a> (非常绚丽)  </li>
<li><a href="https://github.com/dataxpress/UICountingLabel" target="_blank" rel="external">UICountingLabel</a> (数字动态变化,有动画效果)  </li>
<li><a href="https://github.com/android1989/CharacterText" target="_blank" rel="external">CharacterText</a> (相比楼上,更简单实用)  </li>
</ul>
<h2 id="UIButton"><a href="#UIButton" class="headerlink" title="UIButton"></a><a id="UIButton"></a><font color="IndianRed">UIButton</font></h2><ul>
<li><a href="https://github.com/K-cat/CatZanButton" target="_blank" rel="external">CatZanButton</a> (A animation button for “赞/Zan”)  </li>
<li><a href="https://github.com/okmr-d/DOFavoriteButton" target="_blank" rel="external">DOFavoriteButton_swift</a> (Cute Animated Button written in Swift.)    </li>
<li><a href="https://github.com/entotsu/TKAnimatedCheckButton" target="_blank" rel="external">TKAnimatedCheckButton</a>    </li>
<li><a href="https://github.com/yoavlt/LiquidFloatingActionButton" target="_blank" rel="external">LiquidFloatingActionButton</a> (会伸长的+)  </li>
<li><a href="https://github.com/KittenYang/KYGooeyMenu" target="_blank" rel="external">KYGooeyMenu</a> (动画小王子KY出品,粘性弹出按钮,也可以作为UITabBarVC的中间按钮)  </li>
<li><a href="https://github.com/Akateason/XTNetReloader" target="_blank" rel="external">XTNetReloader</a> (提示”没有wifi”的view和一个”重新加载”的button)  </li>
<li><a href="https://github.com/zoonooz/ZFRippleButton" target="_blank" rel="external">ZFRippleButton</a> (点击button不同部位,出现不同的动画反应)  </li>
</ul>
<h2 id="UITextField"><a href="#UITextField" class="headerlink" title="UITextField"></a><a id="UITextField"></a><font color="IndianRed">UITextField</font></h2><ul>
<li><a href="https://github.com/raulriera/TextFieldEffects" target="_blank" rel="external">TextFieldEffects</a> (Custom UITextFields effects inspired by Codrops, built using Swift)  </li>
<li><a href="https://github.com/nixzhu/KeyboardMan" target="_blank" rel="external">KeyboardMan</a> (iOS8后键盘通知就不太正常了…)  </li>
<li><a href="https://github.com/FahimF/FloatLabelFields" target="_blank" rel="external">FloatLabelFields</a> ( 基于”Float Label Pattern”的内嵌浮动标签输入效果 Swift 版实现类库)  </li>
</ul>
<h2 id="UIImage/UIImageView"><a href="#UIImage/UIImageView" class="headerlink" title="UIImage/UIImageView"></a><a id="UIImage/UIImageView"></a><font color="IndianRed">UIImage/UIImageView</font></h2><ul>
<li><a href="https://github.com/Flipboard/FLAnimatedImage" target="_blank" rel="external">FLAnimatedImage</a> (Performant animated GIF engine for iOS)  </li>
<li><a href="https://github.com/kaishin/ImageScout" target="_blank" rel="external">ImageScout</a> (最小网络代价获得图片大小（宽和高）及类型，它对于很多场合，比如：布局和排版都有积极作用)  </li>
<li><a href="https://github.com/kaishin/gifu" target="_blank" rel="external">gifu</a> (高性能 GIF 显示类库 Swift 版本)  </li>
</ul>
<h2 id="UITableView/UITableViewCell"><a href="#UITableView/UITableViewCell" class="headerlink" title="UITableView/UITableViewCell"></a><a id="UITableView/UITableViewCell"></a><font color="IndianRed">UITableView/UITableViewCell</font></h2><ul>
<li><a href="https://github.com/johnil/VVeboTableViewDemo" target="_blank" rel="external">VVeboTableViewDemo</a> (极致优化tableview…)  </li>
<li><a href="https://github.com/CEWendel/SWTableViewCell" target="_blank" rel="external">SWTableViewCell</a> (An easy-to-use UITableViewCell subclass that implements a swippable content view which exposes utility buttons (similar to iOS 7 Mail Application))  </li>
<li><a href="https://github.com/MortimerGoro/MGSwipeTableCell" target="_blank" rel="external">MGSwipeTableCell</a> (An easy to use UITableViewCell subclass that allows to display swippable buttons with a variety of transitions.)  </li>
<li><a href="https://github.com/adad184/MMParallaxCell" target="_blank" rel="external">MMParallaxCell</a>  </li>
</ul>
<h2 id="UICollectionView"><a href="#UICollectionView" class="headerlink" title="UICollectionView"></a><a id="UICollectionView"></a><font color="IndianRed">UICollectionView</font></h2><ul>
<li><a href="https://github.com/jamztang/CSStickyHeaderFlowLayout" target="_blank" rel="external">CSStickyHeaderFlowLayout</a> (UICollectionView replacement of UITableView. Do even more like Parallax Header, Sticky Section Header. Made for iOS 7. )  </li>
<li><a href="https://github.com/DeveloperLx/LxGridView-swift" target="_blank" rel="external">LxGridView-swift</a> (Imitation iOS system desktop icon arrangement and interaction by UICollectionView!)  </li>
<li><a href="https://github.com/CezaryKopacz/CKWaveCollectionViewTransition" target="_blank" rel="external">CKWaveCollectionViewTransition</a> (Cool wave like transition between two or more UICollectionView)  </li>
<li><a href="https://github.com/matbeich/StickyCollectionView" target="_blank" rel="external">StickyCollectionView</a> (实现了 cell 在滚动时吸附在顶端并且之后的 cell 在其上方覆盖的效果)  </li>
</ul>
<h2 id="UITabBarViewController"><a href="#UITabBarViewController" class="headerlink" title="UITabBarViewController"></a><a id="UITabBarViewController"></a><font color="IndianRed">UITabBarViewController</font></h2><ul>
<li><a href="https://github.com/Ramotion/animated-tab-bar" target="_blank" rel="external">animated-tab-bar</a> (如名,animation_tab_bar)  </li>
<li><a href="https://github.com/ChenYilong/CYLTabBarController" target="_blank" rel="external">CYLTabBarController</a>  </li>
</ul>
<h2 id="UINavigationBar"><a href="#UINavigationBar" class="headerlink" title="UINavigationBar"></a><a id="UINavigationBar"></a><font color="IndianRed">UINavigationBar</font></h2><ul>
<li><a href="https://github.com/andreamazz/AMScrollingNavbar" target="_blank" rel="external">AMScrollingNavbar</a>  </li>
<li><a href="https://github.com/telly/TLYShyNavBar" target="_blank" rel="external">TLYShyNavBar</a>  </li>
<li><a href="https://github.com/DanisFabric/RainbowNavigation" target="_blank" rel="external">RainbowNavigation</a> (UINavigationBar颜色变化的十分优秀的解决方案)  </li>
<li><a href="https://github.com/MoZhouqi/KMNavigationBarTransition" target="_blank" rel="external">KMNavigationBarTransition</a> (过渡效果顺滑自然，你不用写一行代码,只用关心被 push 的 view controller 的导航栏的背景样式)  </li>
</ul>
<h2 id="Left_7CTop_Menu"><a href="#Left_7CTop_Menu" class="headerlink" title="Left|Top_Menu"></a><a id="Left|Top_Menu"></a><font color="IndianRed">Left|Top_Menu</font></h2><ul>
<li><a href="https://github.com/uacaps/PageMenu" target="_blank" rel="external">PageMenu</a> (A paging menu controller built from other view controllers placed inside a scroll view (like Spotify, Windows Phone, Instagram),类似于网易,今日头条那种顶部菜单,下面滚动VC的控件)    </li>
<li><a href="https://github.com/wangmchn/WMPageController" target="_blank" rel="external">WMPageController</a> (不知道这个库封装的如何,同事在项目中用了..感觉一般)  </li>
<li><a href="https://github.com/iThinkerYZ/YZDisplayViewController" target="_blank" rel="external">YZDisplayViewController</a> (仿今日头条的页面切换,最近性能优化了一下)  </li>
<li><a href="https://github.com/Yalantis/GuillotineMenu" target="_blank" rel="external">GuillotineMenu</a> (自定义push的Top菜单栏)     </li>
<li><a href="https://github.com/PhamBaTho/BTNavigationDropdownMenu" target="_blank" rel="external">BTNavigationDropdownMenu</a> (在导航栏Title切换的菜单控件)  </li>
<li><a href="https://github.com/Yalantis/Persei" target="_blank" rel="external">Persei</a> (Animated top menu for UITableView / UICollectionView / UIScrollView written in Swift )    </li>
</ul>
<h2 id="Push/Present"><a href="#Push/Present" class="headerlink" title="Push/Present"></a><a id="Push/Present"></a><font color="IndianRed">Push/Present</font></h2><ul>
<li><a href="https://github.com/forkingdog/FDFullscreenPopGesture#rd?sukey=cbbc36a2500a2e6c699bcaa2c3a2a4121c317876c7a2b222e5a82d353c00c6347c9f0f0036b4cf7fb377d54672c9869a" target="_blank" rel="external">FDFullscreenPopGesture</a> (纵享丝滑的手势操作…阳神出品)  </li>
<li><a href="https://github.com/recruit-mp/RMPZoomTransitionAnimator" target="_blank" rel="external">RMPZoomTransitionAnimator</a> (A custom zooming transition animation for UIViewController)  </li>
<li><a href="https://github.com/entotsu/TKSubmitTransition" target="_blank" rel="external">TKSubmitTransition</a> (Animated UIButton of Loading Animation and Transition Animation)  </li>
<li><a href="https://github.com/andreamazz/BubbleTransition" target="_blank" rel="external">BubbleTransition</a>  </li>
<li><a href="https://github.com/DianQK/TransitionTreasury" target="_blank" rel="external">TransitionTreasury_Swift</a> (各式转场动画,可以在<a href="http://transitiontreasury.com/" target="_blank" rel="external">这里</a>查看他的gif效果图)   </li>
</ul>
<h2 id="u65E5_u5386UI"><a href="#u65E5_u5386UI" class="headerlink" title="日历UI"></a><a id="日历UI"></a><font color="IndianRed">日历UI</font></h2><ul>
<li><a href="https://github.com/jonathantribouharet/JTCalendar" target="_blank" rel="external">JTCalendar</a>  </li>
<li><a href="https://github.com/jivesoftware/PDTSimpleCalendar" target="_blank" rel="external">PDTSimpleCalendar</a>  </li>
<li><a href="https://github.com/Mozharovsky/CVCalendar" target="_blank" rel="external">CVCalendar</a></li>
</ul>
<h2 id="UIWebView/WebViewController"><a href="#UIWebView/WebViewController" class="headerlink" title="UIWebView/WebViewController"></a><a id="UIWebView"></a><font color="IndianRed">UIWebView/WebViewController</font></h2><ul>
<li><a href="https://github.com/ninjinkun/NJKWebViewProgress" target="_blank" rel="external">NJKWebViewProgress</a>  </li>
<li><a href="https://github.com/rnapier/RNCachingURLProtocol" target="_blank" rel="external">RNCachingURLProtocol</a>  </li>
<li><a href="https://github.com/TimOliver/TOWebViewController" target="_blank" rel="external">TOWebViewController</a> (快速展示web页面的vc)  </li>
</ul>
<h2 id="u5F15_u5BFC_u9875/_u65B0_u624B_u64CD_u4F5C_u6307_u793A"><a href="#u5F15_u5BFC_u9875/_u65B0_u624B_u64CD_u4F5C_u6307_u793A" class="headerlink" title="引导页/新手操作指示"></a><a id="guide page"></a><font color="IndianRed">引导页/新手操作指示</font></h2><ul>
<li><a href="https://github.com/mamaral/Onboard" target="_blank" rel="external">Onboard</a> (非常棒的引导页制作库)  </li>
<li><a href="https://github.com/IFTTT/RazzleDazzle" target="_blank" rel="external">RazzleDazzle_swift</a> (A simple keyframe-based animation framework for iOS, written in Swift. Perfect for scrolling app intros.同上)  </li>
<li><a href="https://github.com/likedan/KDIntroView" target="_blank" rel="external">KDIntroView</a>  </li>
<li><a href="https://github.com/hyperoslo/Presentation" target="_blank" rel="external">Presentation_swift</a>  </li>
<li><a href="https://github.com/ariok/BWWalkthrough" target="_blank" rel="external">BWWalkthrough</a> (a class to build custom walkthroughs for your iOS App)  </li>
<li><a href="https://github.com/ephread/Instructions" target="_blank" rel="external">Instructions</a> (新功能指引页面)  </li>
</ul>
<h2 id="UI_other__u4E0D_u77E5_u5230_u548B_u5206_u7C7B_u4E86"><a href="#UI_other__u4E0D_u77E5_u5230_u548B_u5206_u7C7B_u4E86" class="headerlink" title="UI other 不知到咋分类了"></a><a id="UI other"></a><font color="IndianRed">UI other 不知到咋分类了</font></h2><ul>
<li><a href="https://github.com/Draveness/DKNightVersion" target="_blank" rel="external">DKNightVersion</a> (白天/夜间模式切换)  </li>
<li><a href="https://github.com/Yalantis/Koloda" target="_blank" rel="external">Koloda</a> (卡片式UIView)  </li>
<li><a href="https://github.com/ninjaprox/NVActivityIndicatorView" target="_blank" rel="external">NVActivityIndicatorView</a> (Collection of nice loading animations)  </li>
<li><a href="https://github.com/weng1250/WZLBadge" target="_blank" rel="external">WZLBadge</a> (一行代码搞定各种小红点)  </li>
<li><a href="https://github.com/Ramotion/paper-switch" target="_blank" rel="external">paper-switch</a> (类库实现了当 Switch 组件开/关切换时，平滑过渡到父视图的变换效果功能（核心类继承了 UISwitch）)    </li>
<li><a href="https://github.com/hyperoslo/Whisper" target="_blank" rel="external">Whisper</a> (使用简单、功能实用的消息及应用通知组件)  </li>
<li><a href="https://github.com/cruffenach/CRToast" target="_blank" rel="external">CRToast</a> (从状态栏弹出消息提醒)  </li>
<li><a href="https://github.com/lovels/LBTagView" target="_blank" rel="external">LBTagView</a> (添加标签视图)  </li>
</ul>
<h2 id="AutoLayout"><a href="#AutoLayout" class="headerlink" title="AutoLayout"></a><a id="AutoLayout"></a><font color="IndianRed">AutoLayout</font></h2><ul>
<li><a href="http://www.hmttommy.com/2015/04/14/AutolayoutDetail/" target="_blank" rel="external">AutoLayout优秀的开源库</a> (可以参考LZ之前写的这篇文章)  </li>
<li><a href="https://github.com/mamaral/Neon" target="_blank" rel="external">Neon</a>  </li>
<li><a href="https://github.com/forkingdog/FDStackView" target="_blank" rel="external">FDStackView</a> (这个项目通过巧妙的方式用自己的一套实现在非 iOS 9 中替换了 UIStackView 的链接和实现，让我们可以在低至 iOS 6 的系统上使用UIStackView，并且保持和最新的 iOS 9 上同样的用法和语法)  </li>
<li><a href="https://github.com/zekunyan/AutolayoutExampleWithMasonry" target="_blank" rel="external">AutolayoutExampleWithMasonry</a> (有一系列的文章来讲明使用)        </li>
</ul>
<h2 id="Pop-up/Pop-down_View"><a href="#Pop-up/Pop-down_View" class="headerlink" title="Pop-up/Pop-down View"></a><a id="Pop-up/Pop-down"></a><font color="IndianRed">Pop-up/Pop-down View</font></h2><ul>
<li><a href="https://github.com/12207480/DOPDropDownMenu-Enhanced" target="_blank" rel="external">DOPDropDownMenu-Enhanced</a> (类似美团的下拉选择菜单)  </li>
<li><a href="https://github.com/jsfu/JSDropDownMenu" target="_blank" rel="external">JSDropDownMenu</a>  </li>
<li><a href="http://code.cocoachina.com/detail/315440/DropdownListView" target="_blank" rel="external">DropdownListView</a>  </li>
<li><a href="https://github.com/kolyvan/kxmenu" target="_blank" rel="external">kxmenu</a> (举例:点击微信app上的那个”+”弹出的视图)  </li>
<li><a href="https://github.com/zpz1237/NirKxMenu" target="_blank" rel="external">NirKxMenu_swift</a> (同上)  </li>
<li><a href="https://github.com/adad184/MMPopupView" target="_blank" rel="external">MMPopupView</a> (Pop-up based view(e.g. alert sheet), can easily customize.)    </li>
<li><a href="https://github.com/xiekw2010/DXAlertView" target="_blank" rel="external">DXAlertView</a> (自定义动画效果的alertview,实现还是比较简单的)  </li>
<li><a href="https://github.com/vikmeup/SCLAlertView-Swift" target="_blank" rel="external">SCLAlertView-Swift</a> (Beautiful animated Alert View. Written in Swift)  </li>
<li><a href="https://github.com/codestergit/SweetAlert-iOS" target="_blank" rel="external">SweetAlert-iOS</a> (Live animated Alert View for iOS written in Swift)  </li>
<li><a href="https://github.com/steipete/PSTAlertController" target="_blank" rel="external">PSTAlertController</a> (兼容 iOS7的 XXAlertController，接口跟UIAlertController 一模一样，高低版本通用–另外这个作者可以follow一下,^_^)    </li>
<li><a href="https://github.com/jaydee3/JDStatusBarNotification" target="_blank" rel="external">JDStatusBarNotification</a> (呈现在状态栏的通知视图)  </li>
</ul>
<h2 id="u4E0B_u62C9_u5237_u65B0_u548C_u4E0A_u62C9_u52A0_u8F7D"><a href="#u4E0B_u62C9_u5237_u65B0_u548C_u4E0A_u62C9_u52A0_u8F7D" class="headerlink" title="下拉刷新和上拉加载"></a><a id="refresh_up/down"></a><font color="IndianRed">下拉刷新和上拉加载</font></h2><ul>
<li><a href="https://github.com/CoderMJLee/MJRefresh" target="_blank" rel="external">MJRefresh</a> (不得不说,小码哥的另一个好用的code)  </li>
<li><a href="https://github.com/coolbeet/CBStoreHouseRefreshControl" target="_blank" rel="external">CBStoreHouseRefreshControl</a> (第一感觉就是,会玩)  </li>
<li><a href="https://github.com/cemolcay/PullToRefreshCoreText" target="_blank" rel="external">PullToRefreshCoreText</a> (半塘下拉刷新效果,refresh效果类似今日头条,不难实现)  </li>
<li><a href="https://github.com/Yalantis/Pull-to-Refresh.Rentals-iOS" target="_blank" rel="external">Pull-to-Refresh.Rentals</a>  </li>
<li><a href="https://github.com/entotsu/PullToBounce" target="_blank" rel="external">PullToBounce_swift</a> (Animated “Pull To Refresh” Library for UIScrollView)    </li>
<li><a href="https://github.com/Yalantis/PullToMakeSoup" target="_blank" rel="external">PullToMakeSoup_swift</a> (水煮沸动画…)  </li>
<li><a href="https://github.com/dekatotoro/PullToRefreshSwift" target="_blank" rel="external">PullToRefreshSwift</a>  </li>
<li><a href="https://github.com/gontovnik/DGElasticPullToRefresh" target="_blank" rel="external">DGElasticPullToRefresh</a> (皮筋式的下拉刷新动画)  </li>
<li><a href="https://github.com/jcavar/refresher" target="_blank" rel="external">refresher_Swift</a> (一个常用的下拉即刷新列表工具类，提供开放接口定制刷新动态变换效果)  </li>
<li><a href="https://github.com/DanisFabric/Infinity" target="_blank" rel="external">Infinity_Swift</a> (完全支持自定义交互动画,一句话代码集成)    </li>
</ul>
<h2 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a><a id="animation"></a><font color="IndianRed">Animation</font></h2><ul>
<li><a href="https://github.com/sxyx2008/awesome-ios-animation" target="_blank" rel="external">awesome-ios-animation</a> (A curated list of awesome iOS animation, including Objective-C and Swift libraries)  </li>
<li><a href="https://github.com/Animatious/awesome-animation" target="_blank" rel="external">Animatious Group</a>  </li>
<li><a href="https://github.com/facebook/pop" target="_blank" rel="external">facebook/pop</a> (facebook出品,必属精品)  </li>
<li><a href="https://github.com/MengTo/Spring" target="_blank" rel="external">Spring_Swift</a>  </li>
<li><a href="https://github.com/KittenYang/Animations" target="_blank" rel="external">KittenYang/Animations</a> (动画小王子KittenYang,最近他还出了一本书,LZ也买了,很不错,研读中)  </li>
<li><a href="https://github.com/jhurray/JHChainableAnimations" target="_blank" rel="external">JHChainableAnimations</a> (类masonry的链式语法,棒棒哒)  </li>
<li><a href="https://github.com/Draveness/DKChainableAnimationKit" target="_blank" rel="external">DKChainableAnimationKit_swift</a> (同上,swift版本)  </li>
<li><a href="https://github.com/suguru/Cheetah" target="_blank" rel="external">Cheetah</a> (Easy animation library on iOS with Swift2)  </li>
<li><a href="https://github.com/daltoniam/DCAnimationKit" target="_blank" rel="external">DCAnimationKit</a> (A collection of animations for iOS. Simple, just add water animations.)  </li>
<li><a href="https://github.com/icanzilb/EasyAnimation" target="_blank" rel="external">EasyAnimation</a>  </li>
<li><a href="https://github.com/search?utf8=✓&amp;q=WaterWave" target="_blank" rel="external">WaterWave</a> (水波纹效果)  </li>
<li><a href="https://github.com/shu223/PulsingHalo" target="_blank" rel="external">PulsingHalo</a> (水涟漪动画)  </li>
</ul>
<h2 id="u56FE_u8868/_u8FDB_u5EA6_u6761/Loading"><a href="#u56FE_u8868/_u8FDB_u5EA6_u6761/Loading" class="headerlink" title="图表/进度条/Loading"></a><a id="chart_progress"></a><font color="IndianRed">图表/进度条/Loading</font></h2><ul>
<li><a href="https://github.com/sxyx2008/awesome-ios-chart" target="_blank" rel="external">aswesome-iOS-chart</a> (A curated list of awesome iOS chart libraries, including Objective-C and Swift…排在第一个的就是<code>PNChart</code>)  </li>
<li><a href="https://github.com/danielgindi/ios-charts" target="_blank" rel="external">ios-charts</a> (Android 图表开源库 MPAndroidChart 的 Swift 版)  </li>
<li><a href="https://github.com/matibot/MBCircularProgressBar" target="_blank" rel="external">MBCircularProgressBar</a> (2/3圆进度条)  </li>
<li><a href="https://github.com/12207480/TYWaterWaveView" target="_blank" rel="external">TYWaterWaveView</a> (水波圆形进度控件)  </li>
<li><a href="https://github.com/core-plot/core-plot" target="_blank" rel="external">core-plot</a>  </li>
<li><a href="https://github.com/mrackwitz/MRProgress" target="_blank" rel="external">MRProgress</a> (Collection of iOS drop-in components to visualize progress)  </li>
<li><a href="https://github.com/UrbanApps/UAProgressView" target="_blank" rel="external">UAProgressView</a> (UAProgressView is a simple and lightweight, yet powerful animated circular progress view)  </li>
<li><a href="https://github.com/PowerAuras/Win7LoadingBar" target="_blank" rel="external">Win7LoadingBar</a> (ios上的windows7风格的进度条)  </li>
<li><a href="https://github.com/YannickL/YLProgressBar" target="_blank" rel="external">YLProgressBar</a> (UIProgressView replacement with an highly and fully customizable animated progress bar in pure Core Graphics)  </li>
<li><a href="https://github.com/devSC/WSProgressHUD" target="_blank" rel="external">WSProgressHUD</a> (举例:loading…加载中…等进度蒙层)  </li>
<li><a href="https://github.com/jdg/MBProgressHUD" target="_blank" rel="external">MBProgressHUD</a> (同上,比较火,很多app都用到了,当然有时间还是自定义好)  </li>
<li><a href="https://github.com/SergioChan/SCCatWaitingHUD" target="_blank" rel="external">SCCatWaitingHUD</a> (可爱的动画loading…)  </li>
<li><a href="https://github.com/eternityz/RWBarChartView" target="_blank" rel="external">RWBarChartView</a> (能够滑动的支柱形图表)  </li>
<li><a href="https://github.com/NghiaTranUIT/FeSpinner" target="_blank" rel="external">FeSpinner</a> (各种Loading动画)  </li>
</ul>
<h2 id="CoreText"><a href="#CoreText" class="headerlink" title="CoreText"></a><a id="coretext"></a><font color="IndianRed">CoreText</font></h2><ul>
<li><a href="https://github.com/TTTAttributedLabel/TTTAttributedLabel" target="_blank" rel="external">TTTAttributedLabel</a> (图文混排…超链接…iOS7之后有了Textkit)  </li>
<li><a href="https://github.com/12207480/TYAttributedLabel" target="_blank" rel="external">TYAttributedLabel</a>  (LZ项目用它,还解决了”截断”问题,类似于appstore介绍的”..更多”)  </li>
<li><a href="https://github.com/molon/MLEmojiLabel" target="_blank" rel="external">MLEmojiLabel</a>  </li>
<li><a href="https://github.com/johnil/GCD_Label" target="_blank" rel="external">GCD_Label</a>  </li>
<li><a href="https://github.com/ibireme/YYText" target="_blank" rel="external">YYText</a>  </li>
<li><a href="https://github.com/optonaut/ActiveLabel.swift" target="_blank" rel="external">ActiveLabel.swift</a> (UILabel drop-in replacement supporting Hashtags (#), Mentions (@) and URLs (http://) written in Swift)  </li>
</ul>
<h2 id="u97F3_u9891_u89C6_u9891"><a href="#u97F3_u9891_u89C6_u9891" class="headerlink" title="音频视频"></a><a id="Video"></a><font color="IndianRed">音频视频</font></h2><ul>
<li><a href="https://github.com/bilibili" target="_blank" rel="external">bilibili</a>  </li>
<li><a href="https://github.com/36Kr-Mobile/KRVideoPlayer" target="_blank" rel="external">KRVideoPlayer</a> (类似Weico的播放器，支持竖屏模式下全屏播放<br>)  </li>
<li><a href="https://github.com/douban/DOUAudioStreamer" target="_blank" rel="external">DOUAudioStreamer</a>  </li>
<li><a href="https://github.com/PandaraWen/SBVideoCaptureDemo" target="_blank" rel="external">SBVideoCaptureDemo</a>  </li>
<li><a href="https://github.com/Aufree/ESTMusicPlayer" target="_blank" rel="external">ESTMusicPlayer</a> (类似于网易云音乐的完整Demo,值得一看)  </li>
</ul>
<h2 id="IM"><a href="#IM" class="headerlink" title="IM"></a><a id="IM"></a><font color="IndianRed">IM</font></h2><ul>
<li><a href="https://github.com/jessesquires/JSQMessagesViewController" target="_blank" rel="external">JSQMessagesViewController</a> (聊天的UI界面框架)</li>
</ul>
<h2 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a><a id="GCD"></a><font color="IndianRed">GCD</font></h2><ul>
<li><a href="https://github.com/khoiln/RunKit" target="_blank" rel="external">RunKit</a> (针对GCD框架的一个友好访问封装库,支持方法链式调用)  </li>
<li><a href="https://github.com/duemunk/Async" target="_blank" rel="external">Async</a> (Syntactic sugar in Swift for asynchronous dispatches in Grand Central Dispatch,封装了系统的GCD,提供的接口简洁方便)  </li>
</ul>
<h2 id="String/CGFloat/Int/Double"><a href="#String/CGFloat/Int/Double" class="headerlink" title="String/CGFloat/Int/Double"></a><a id="String"></a><font color="IndianRed">String/CGFloat/Int/Double</font></h2><ul>
<li><a href="https://github.com/marmelroy/Format" target="_blank" rel="external">Format</a> (针对数字、货币、地址及颜色的格式化工具库)    </li>
<li><a href="https://github.com/mattt/Surge" target="_blank" rel="external">Surge</a> (基于苹果 Accelerate 高性能计算框架库，计算效率提升惊人)  </li>
</ul>
<h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a><a id="Date"></a><font color="IndianRed">Date</font></h2><ul>
<li><a href="https://github.com/malcommac/SwiftDate" target="_blank" rel="external">SwiftDate</a> (特别完整、强大的日期操作管理类库。它几乎涵盖了已知开源日期类库所有优秀特性)    </li>
<li><a href="https://github.com/akosma/SwiftMoment" target="_blank" rel="external">SwiftMoment</a> (时间和日历函数封装库)   </li>
</ul>
<h2 id="Categories"><a href="#Categories" class="headerlink" title="Categories"></a><a id="categories"></a><font color="IndianRed">Categories</font></h2><ul>
<li><a href="https://github.com/shaojiankui/IOS-Categories" target="_blank" rel="external">iOS-Categories</a> (iOS中的各种Objective-C Category, a collection of useful Objective-C Categories extending iOS Frameworks such as Foundation,UIKit,CoreData,QuartzCore,CoreLocation,MapKit Etc.)    </li>
<li><a href="https://github.com/goktugyil/EZSwiftExtensions" target="_blank" rel="external">EZSwiftExtensions</a> (同上swift版本)  </li>
<li><a href="https://github.com/pNre/ExSwift" target="_blank" rel="external">ExSwift</a> (同上)  </li>
<li><a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell" target="_blank" rel="external">UITableView-FDTemplateLayoutCell</a> (阳神出品,cell动态高度必备,就算你不支持iOS7,iOS8+虽可以自动计算高度,但重复计算cell高度也会让你需要用到的)  </li>
<li><a href="https://github.com/EnjoySR/ESSeparatorInset" target="_blank" rel="external">ESSeparatorInset</a> (一行代码移除 UITableView 分割线左边的默认的间距)  </li>
<li><a href="https://github.com/malcommac/SwiftDate" target="_blank" rel="external">SwiftDate</a> (Easy NSDate Management in Swift)  </li>
<li><a href="https://github.com/evgenyneu/SigmaSwiftStatistics" target="_blank" rel="external">SigmaSwiftStatistics</a> (各种数学计算)  </li>
</ul>
<h2 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a><a id="Tools"></a><font color="IndianRed">Tools</font></h2><ul>
<li><a href="https://github.com/nst/iOS-Runtime-Headers" target="_blank" rel="external">iOS-Runtime-Headers</a> (查找那些方法属于publie/private/dylib)  </li>
<li><a href="https://github.com/callmewhy/PleaseBaoMe" target="_blank" rel="external">PleaseBaoMe</a> (A useful tool to view SQLite file in Web browser during app running procedure.)    </li>
<li><a href="https://github.com/facebook/xctool" target="_blank" rel="external">xctool</a> (自动打包)  </li>
<li><a href="https://github.com/Abizern/xcode-snippets" target="_blank" rel="external">xcode-snippets</a> (代码块,比如你需要经常写tableview的代理方法,可以把他们做成你常用的代码块)  </li>
<li><a href="https://github.com/nixzhu/Proposer" target="_blank" rel="external">Proposer_Swift</a> (它能以单个 API 处理 iOS 上的权限请求，以便使用前确认可访问“相册”、“相机”、“麦克风”、“通讯录”或“用户位置”。)  </li>
<li><a href="https://github.com/madebybowtie/FlagKit" target="_blank" rel="external">FlagKit</a> (这个库包含了设计漂亮，风格统一的一套旗帜，并且按照国家代码进行了编排，使得我们可以很容易地使用用户设备语言来选择和显示对应的旗帜，十分方便)  </li>
<li><a href="https://github.com/krzyzanowskim/CryptoSwift" target="_blank" rel="external">CryptoSwift</a> (纯swift写的”MD5”,”BASE64”等加密库)  </li>
<li><a href="https://github.com/hackxhj/BeautyAddressBook" target="_blank" rel="external">BeautyAddressBook</a> (通讯录…)  </li>
<li><a href="https://github.com/facebook/Tweaks" target="_blank" rel="external">Facebook Tweaks</a> (不需要重复编译微调UI和动画)    </li>
<li><a href="https://github.com/mac-cain13/R.swift" target="_blank" rel="external">R.swift</a> (Get strong typed, autocompleted resources like images, fonts and segues in Swift projects,谁用谁知道)  </li>
<li><a href="https://github.com/AliSoftware/SwiftGen" target="_blank" rel="external">SwiftGen</a> (A collection of Swift tools to generate Swift code (enums for your assets, storyboards, Localizable.strings, …))  </li>
<li><a href="https://github.com/kaandedeoglu/Shark" target="_blank" rel="external">Shark_swift</a> (Swift Script that transforms the .xcassets folder into a type safe enum)  </li>
<li><a href="https://github.com/SwiftyBeaver/SwiftyBeaver" target="_blank" rel="external">SwiftyBeaver</a> (log日志输出,颜色变换/快速)  </li>
<li><a href="https://github.com/DeveloperLx/LxDBAnything" target="_blank" rel="external">LxDBAnything</a> (log日志输出,非常的直观和好用)  </li>
<li><a href="https://github.com/VerbalExpressions/SwiftVerbalExpressions" target="_blank" rel="external">SwiftVerbalExpressions</a> (有助于构建困难的正则表达式-从令人敬畏的 JavaScript VerbalExpressions 移植过来)  </li>
<li><a href="https://github.com/dsxNiubility/Wonderful" target="_blank" rel="external">Wonderful</a> (一个非常好用的色彩库)    </li>
</ul>
<h2 id="Unit_Testing"><a href="#Unit_Testing" class="headerlink" title="Unit Testing"></a><a id="unit testing"></a><font color="IndianRed">Unit Testing</font></h2><ul>
<li><a href="https://github.com/Quick/Quick" target="_blank" rel="external">Quick</a>  </li>
<li><a href="https://github.com/kiwi-bdd/Kiwi" target="_blank" rel="external">Kiwi</a>  </li>
<li><a href="https://github.com/kif-framework/KIF" target="_blank" rel="external">KIF</a>  </li>
</ul>
<h2 id="u7F51_u7EDC_u72B6_u51B5_u76D1_u6D4B"><a href="#u7F51_u7EDC_u72B6_u51B5_u76D1_u6D4B" class="headerlink" title="网络状况监测"></a><a id="Reachability"></a><font color="IndianRed">网络状况监测</font></h2><ul>
<li><a href="https://github.com/tonymillion/Reachability" target="_blank" rel="external">Reachability</a>    </li>
<li><a href="https://github.com/ashleymills/Reachability.swift" target="_blank" rel="external">Reachability.swift</a>  </li>
<li><a href="https://github.com/SSA111/SSASwiftReachability" target="_blank" rel="external">SSASwiftReachability</a>  </li>
</ul>
<h2 id="keychain"><a href="#keychain" class="headerlink" title="keychain"></a><a id="keychain"></a><font color="IndianRed">keychain</font></h2><ul>
<li><a href="https://github.com/matthewpalmer/Locksmith" target="_blank" rel="external">Locksmith_swift</a>  </li>
<li><a href="https://github.com/soffes/sskeychain" target="_blank" rel="external">sskeychain</a></li>
</ul>
<h2 id="Xcode__u63D2_u4EF6"><a href="#Xcode__u63D2_u4EF6" class="headerlink" title="Xcode 插件"></a><a id="Xcode"></a><font color="IndianRed">Xcode 插件</font></h2><ul>
<li><a href="https://github.com/supermarin/Alcatraz" target="_blank" rel="external">Alcatraz</a> (Package manager for Xcode,有它装插件实在是太方便了)</li>
<li><a href="https://github.com/rickytan/RTImageAssets" target="_blank" rel="external">RTImageAssets</a> (A Xcode plugin to automatically generate @2x, @1x image from @3x image for you, or upscale to @3x from @2x)  </li>
<li><a href="https://github.com/FuzzyAutocomplete/FuzzyAutocompletePlugin" target="_blank" rel="external">FuzzyAutocompletePlugin</a> (没它都不会写代码了…)    </li>
<li><a href="https://github.com/travisjeffery/ClangFormat-Xcode" target="_blank" rel="external">ClangFormat-Xcode</a> (Xcode plug-in to to use clang-format from in Xcode and consistently format your code with Clang)  </li>
<li><a href="https://github.com/MakeZL/ZLGotoSandboxPlugin" target="_blank" rel="external">ZLGotoSandboxPlugin</a> (从xcode中快速跳转到沙盒)      </li>
<li><a href="https://github.com/DeskConnect/SBShortcutMenuSimulator" target="_blank" rel="external">SBShortcutMenuSimulator</a> (3D Touch shortcuts in the Simulator)  </li>
<li><a href="https://github.com/EnjoySR/ESJsonFormat-Xcode" target="_blank" rel="external">ESJsonFormat-Xcode</a> (将JSON格式化输出为模型的属性,配合MJExtension很nice)      </li>
<li><a href="https://github.com/markohlebar/Peckham" target="_blank" rel="external">Peckham</a> (快捷引入头文件)  </li>
</ul>
<h2 id="mac__u63D2_u4EF6"><a href="#mac__u63D2_u4EF6" class="headerlink" title="mac 插件"></a><a id="mac"></a><font color="IndianRed">mac 插件</font></h2><ul>
<li><a href="https://github.com/brunophilipe/Cakebrew" target="_blank" rel="external">Cakebrew</a> ( Homebrew 量身定做的图形界面应用, 可以方便你查看 Homebrew 下载过的软件包具体信息, 并可对其进行安装, 卸载等操作)  </li>
</ul>
<h2 id="u4E66_u7C4D"><a href="#u4E66_u7C4D" class="headerlink" title="书籍"></a><a id="book"></a><font color="IndianRed">书籍</font></h2><ul>
<li><a href="https://github.com/oa414/objc-zen-book-cn" target="_blank" rel="external">禅与 Objective-C 编程艺术 </a>  </li>
<li><a href="https://github.com/numbbbbb/the-swift-programming-language-in-chinese" target="_blank" rel="external">the-swift-programming-language-in-chinese</a>  </li>
<li><a href="https://selfstore.io/products/367" target="_blank" rel="external">Producter - 让产品从 0 到 1</a>  </li>
<li><a href="https://zsisme.gitbooks.io/ios-/content/index.html" target="_blank" rel="external">iOS Core Animation: Advanced Techniques中文译本</a>  </li>
<li><a href="https://github.com/ChenYilong/iOS9AdaptationTips" target="_blank" rel="external">iOS9适配系列教程</a>  </li>
</ul>
<h2 id="u4ED6_u4EBA_u63A8_u8350"><a href="#u4ED6_u4EBA_u63A8_u8350" class="headerlink" title="他人推荐"></a><a id="otherCompany"></a><font color="IndianRed">他人推荐</font></h2><ul>
<li><a href="http://adad184.com/2015/07/08/my-favorite-libraries-and-plugins/?sukey=66d4519b2d3854cd422400f82849a2def4b7516bcbc0e3feb93a32fa2ca3a878d283f32c9fce64cafc475ed52b8b6097" target="_blank" rel="external">个人常用iOS第三方库以及XCode插件介绍</a>  </li>
<li><a href="http://www.cocoachina.com/ios/20140123/7746.html" target="_blank" rel="external">iOS第三方开源库的吐槽和备忘</a>  </li>
<li><a href="http://www.jianshu.com/p/207a3879c41f" target="_blank" rel="external">公司用到的一些 iOS 开源库和第三方组件</a>  </li>
<li><a href="http://blog.rpplusplus.me/blog/2014/02/11/facebook-paper-used-3rd/" target="_blank" rel="external">Facebook Paper使用的第三方库</a>  </li>
<li><a href="http://rookie.org.cn/2015/07/16/thirdToos/" target="_blank" rel="external">thirdToos</a> (妹子..)  </li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u76EE_u5F55"><a href="#u76EE_u5F55" class="headerlink" title="目录"></a><font color="IndianRed">目录</font></h2><ul>
<li><a href="/#foreword">前言</a>  </li>
<li><a href="/#all">总览/大集合</a>  </li>
<li><a href="/#network">网络请求Network</a>  </li>
<li><a href="/#datastore">数据存储</a>  </li>
<li><a href="/#image_sync_downloap">图片异步下载缓存</a>    </li>
<li><a href="/#json_model">json/HTML/XML&lt;-&gt;model</a>  </li>
<li><a href="/#framework">框架</a>  </li>
<li><a href="/#Functionalprogramming">Swift函数式编程</a>  </li>
<li><a href="/#UI总览">UI总览</a>  </li>
<li><a href="/#UIImagePickerController">UIImagePickerController/图片浏览</a>  </li>
<li><a href="/#UIScrollView">UIScrollView</a>  </li>
<li><a href="/#UILabel">UILabel</a>  </li>
<li><a href="/#UIButton">UIButton</a>  </li>
<li><a href="/#UITextField">UITextField</a>  </li>
<li><a href="/#UIImage/UIImageView">UIImage/UIImageView</a>    </li>
<li><a href="/#UITableView/UITableViewCell">UITableView/UITableViewCell</a>  </li>
<li><a href="/#UICollectionView">UICollectionView</a>  </li>
<li><a href="/#UITabBarViewController">UITabBarViewController</a>  </li>
<li><a href="/#UINavigationBar">UINavigationBar</a>  </li>
<li><a href="/#Left|Top_Menu">Left|Top_Menu</a></li>
<li><a href="/#Push/Present">Push/Present</a>  </li>
<li><a href="/#日历UI">日历UI</a>    </li>
<li><a href="/#UIWebView">UIWebView</a>  </li>
<li><a href="/#guide page">引导页/新手操作指示</a>  </li>
<li><a href="/#UI other">UI other 不知到咋分类了</a>  </li>
<li><a href="/#AutoLayout">AutoLayout</a>    </li>
<li><a href="/#Pop-up/Pop-down">Pop-up/Pop-down View</a>  </li>
<li><a href="/#refresh_up/down">下拉刷新和上拉加载</a>  </li>
<li><a href="/#animation">Animation</a>  </li>
<li><a href="/#chart_progress">图表/进度条/Loading</a>  </li>
<li><a href="/#coretext">CoreText</a>  </li>
<li><a href="/#Video">音频视频</a>  </li>
<li><a href="/#IM">IM</a>  </li>
<li><a href="/#GCD">GCD</a>    </li>
<li><a href="/#String">String/CGFloat/Int/Double</a>    </li>
<li><a href="/#Date">Date</a>  </li>
<li><a href="/#categories">Categories</a>  </li>
<li><a href="/#Tools">Tools</a>  </li>
<li><a href="/#unit testing">Unit Testing</a></li>
<li><a href="/#Reachability">网络状况监测</a>  </li>
<li><a href="/#keychain">keychain</a>  </li>
<li><a href="/#Xcode">Xcode 插件</a>  </li>
<li><a href="/#mac">mac 插件</a>  </li>
<li><a href="/#book">书籍</a>  </li>
<li><a href="/#otherCompany">他人推荐</a>  </li>
</ul>
<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a><a id="foreword"></a><font color="IndianRed">前言</font></h2><p> Github可说是全球最大的IT”交友约会”网站,各种各样牛逼的<code>open source code</code>,star!star!star!LZ逛github也有些时候了,经常会出现一个困惑,就是star了新的,很多以前star的一想不起名字,就很难找到,要一页一页的翻…想想,如果你star超过了50多页,每一次不得找死…之前我是用<code>Chrome</code>的收藏夹功能来区分,一段时间努力后,就成了下面这个样子:<br> <img src="http://7qn7zn.com1.z0.glb.clouddn.com/chrome%20github.png" alt=""><br> 还是比较方便的,起码完成了分类,只是没能加上自己收藏时对链接的注释(这样查找更快了),昨天朋友推荐了<a href="https://app.astralapp.com/">Astral</a>,通过加标签的方式来实现分类,也很直观明了…那为什么LZ还要做这个整理呢?一是,能够分享出来;二是:可以自己无限的加入自己解释,更快的<code>天下Code,唯快不破</code>查找^_^!<br>]]>
    
    </summary>
    
      <category term="链接 github Demo" scheme="http://hmttommy.com/tags/%E9%93%BE%E6%8E%A5-github-Demo/"/>
    
      <category term="资料" scheme="http://hmttommy.com/categories/%E8%B5%84%E6%96%99/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS CoreAnimation(二)之CATransition]]></title>
    <link href="http://hmttommy.com/2015/05/29/iOS-CoreAnimation-02/"/>
    <id>http://hmttommy.com/2015/05/29/iOS-CoreAnimation-02/</id>
    <published>2015-05-29T02:36:41.000Z</published>
    <updated>2015-07-15T08:34:49.000Z</updated>
    <content type="html"><![CDATA[<p>这一章开始,来讲一下<code>CAAnimation</code>.我们做显式动画主要就是靠它/它的子类了.官方对它的描述是:CAAnimation is an abstract animation class. It provides the basic support for the CAMediaTiming and CAAction protocols. To animate Core Animation layers or Scene Kit objects, create instances of the concrete subclasses CABasicAnimation, CAKeyframeAnimation, CAAnimationGroup, or CATransition.<br>@结构图如下:<br><img src="http://7qn7zn.com1.z0.glb.clouddn.com/coreAni_004.png" alt="">  </p>
<p>标题是<code>CATransition</code>,为什么先写它呢?因为我觉得它有点特殊,主要用来做VC页面切换之间的过渡动画,之前在code4app上一个展示什么立方体-水滴-镜头开关效果等动画就是拿它做的(当时觉得,哇,好炫,不过据说是私有的api,审核不一定能过)…个人感觉用它用的最少,而且iOS7之后苹果提供了自定义VC转场动画的API,已经能够很好的实现各种需求的动画效果.可以参照我之前的文章:<br><a href="http://blog.csdn.net/hmt20130412/article/details/39079905" target="_blank" rel="external">iOS7新特性 ViewController转场切换(一) 以前总结和关键API介绍</a><br><a href="http://blog.csdn.net/hmt20130412/article/details/39080445" target="_blank" rel="external">iOS7新特性 ViewController转场切换(二) 系统视图控制器容器的切换动画—push pop present dismis</a><br><a href="http://blog.csdn.net/hmt20130412/article/details/39119917" target="_blank" rel="external"> iOS7新特性 ViewController转场切换(三) 自定义视图控制器容器的切换—非交互式</a><br><a id="more"></a></p>
<p>直接上一个栗子:<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    func animationCATransition() &#123;</span><br><span class="line">        <span class="keyword">let</span> transitionAni = CATransition()</span><br><span class="line">        transitionAni<span class="built_in">.</span><span class="built_in">duration</span> = <span class="number">1.0</span></span><br><span class="line">        <span class="comment">// 设定动画的进度</span></span><br><span class="line"><span class="comment">//        transitionAni.startProgress = 0.0</span></span><br><span class="line"><span class="comment">//        transitionAni.endProgress = 0.9</span></span><br><span class="line">        <span class="comment">// 页面过渡的类型,栗子:立方体翻转</span></span><br><span class="line">        transitionAni<span class="built_in">.</span><span class="keyword">type</span> = <span class="string">"cube"</span></span><br><span class="line">        <span class="comment">// 页面过渡的方向,栗子:从左开始</span></span><br><span class="line">        transitionAni<span class="built_in">.</span>subtype = kCATransitionFromLeft</span><br><span class="line">        <span class="built_in">self</span><span class="built_in">.</span>navigationController<span class="subst">!</span><span class="built_in">.</span>view<span class="built_in">.</span>layer<span class="built_in">.</span>addAnimation(transitionAni, forKey: nil)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> testVC = <span class="built_in">self</span><span class="built_in">.</span>storyboard<span class="subst">!</span><span class="built_in">.</span>instantiateViewControllerWithIdentifier(<span class="string">"TestViewController"</span>) as<span class="subst">!</span> TestViewController</span><br><span class="line">        <span class="built_in">self</span><span class="built_in">.</span>navigationController<span class="subst">!</span><span class="built_in">.</span>pushViewController(testVC, animated: <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="string">``</span><span class="string">`  </span><br><span class="line">`</span><span class="keyword">type</span><span class="string">`:页面过渡种类</span></span><br></pre></td></tr></table></figure></p>
<p>// 交叉淡化过渡<br>let kCATransitionFade: String<br>// 新视图移到旧视图上面<br>@available(iOS 2.0, <em>)<br>let kCATransitionMoveIn: String<br>// 新视图把旧视图推出去<br>@available(iOS 2.0, </em>)<br>let kCATransitionPush: String<br>// 将旧视图移动,系那是下面的新视图<br>@available(iOS 2.0, *)<br>let kCATransitionReveal: String</p>
<p>–据说是私有的,慎重使用,有的说能过审核,有的说不能过囧–<br>“pageCurl “              向上翻一页<br>“pageUnCurl”             向下翻一页<br>“rippleEffect”           滴水(波纹)效果<br>“suckEffect”             收缩效果，如一块布被抽走或者是被吸收<br>“cube”                   立方体效果<br>“oglFlip”                上下翻转效果<br>“cameraIrisHollowOpen”   镜头开效果<br>“cameraIrisHollowClose”  镜头关效果<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="escape">`s</span>ubtype<span class="escape">`:</span>页面过渡方向</span><br></pre></td></tr></table></figure></p>
<p> kCATransitionFromRight<br> kCATransitionFromLeft<br> kCATransitionFromTop<br> kCATransitionFromBottom<br>```  </p>
<p><code>filter</code>:不太懂…  </p>
<p>@大致就这些了,上一个立方体翻转的效果图…0.0貌似也就那样…<br><img src="http://7qn7zn.com1.z0.glb.clouddn.com/catrasition.gif" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这一章开始,来讲一下<code>CAAnimation</code>.我们做显式动画主要就是靠它/它的子类了.官方对它的描述是:CAAnimation is an abstract animation class. It provides the basic support for the CAMediaTiming and CAAction protocols. To animate Core Animation layers or Scene Kit objects, create instances of the concrete subclasses CABasicAnimation, CAKeyframeAnimation, CAAnimationGroup, or CATransition.<br>@结构图如下:<br><img src="http://7qn7zn.com1.z0.glb.clouddn.com/coreAni_004.png" alt="">  </p>
<p>标题是<code>CATransition</code>,为什么先写它呢?因为我觉得它有点特殊,主要用来做VC页面切换之间的过渡动画,之前在code4app上一个展示什么立方体-水滴-镜头开关效果等动画就是拿它做的(当时觉得,哇,好炫,不过据说是私有的api,审核不一定能过)…个人感觉用它用的最少,而且iOS7之后苹果提供了自定义VC转场动画的API,已经能够很好的实现各种需求的动画效果.可以参照我之前的文章:<br><a href="http://blog.csdn.net/hmt20130412/article/details/39079905">iOS7新特性 ViewController转场切换(一) 以前总结和关键API介绍</a><br><a href="http://blog.csdn.net/hmt20130412/article/details/39080445">iOS7新特性 ViewController转场切换(二) 系统视图控制器容器的切换动画—push pop present dismis</a><br><a href="http://blog.csdn.net/hmt20130412/article/details/39119917"> iOS7新特性 ViewController转场切换(三) 自定义视图控制器容器的切换—非交互式</a><br>]]>
    
    </summary>
    
      <category term="CATransition" scheme="http://hmttommy.com/tags/CATransition/"/>
    
      <category term="CoreAnimation" scheme="http://hmttommy.com/categories/CoreAnimation/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS CoreAnimation(一)之UIKit封装的UIView动画]]></title>
    <link href="http://hmttommy.com/2015/05/27/iOS-CoreAnimation-01/"/>
    <id>http://hmttommy.com/2015/05/27/iOS-CoreAnimation-01/</id>
    <published>2015-05-27T03:00:10.000Z</published>
    <updated>2015-07-15T06:39:24.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Start"><a href="#Start" class="headerlink" title="Start"></a><font color="IndianRed">Start</font></h1><p>我们开发App的时候,经常要用到各种动画来实现炫丽效果,本人也十分的喜欢研究动画,所以打算对于<code>动画-Core Animation</code>相关的知识做个梳理与总结.  </p>
<p><code>Core Animation</code>最大好处是可以帮助Mac或者iPhone的开发者减少代码量。因为如果你想用Core Image或者Open GL实现界面的动画特效，其实也是可以的，主要是非常麻烦。而用Core Animation可以极大简化开发难度和减少代码量。</p>
<p><strong>PS:只是对于基础用法和概念进行整理与说明,各种酷炫效果的Demo就靠大家自己去实现了^_^</strong>  </p>
<p>整体的框架结构大致是:<br><img src="http://7qn7zn.com1.z0.glb.clouddn.com/coreAni_0000.jpeg" alt=""></p>
<p><font color="red">第一章</font>先不介绍关键图层<code>CALayer</code>的知识,先来说说<code>UIKit</code>集成在UIView类中的动画API,在我们日常的开发中,UIKit动画API使用起来十分简单与方便,能满足大部分的基本的动画需求.(其实UIKit动画API的底层使用的也是Core Animation,有的时候在你面试的时候,面试官会问你,<code>UIView+animationBlock</code>的方式,是如何实现动画效果的)<br><a id="more"></a>  </p>
<p><font color="IndianRed">普通形式</font><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 标记动画块开始</span></span><br><span class="line">        UIView.<span class="function"><span class="title">beginAnimations</span><span class="params">(nil, context: nil)</span></span></span><br><span class="line">        <span class="comment">// 设定动画的开始时间,默认为当前时间</span></span><br><span class="line">        <span class="comment">//UIView.setAnimationStartDate(&lt;#T##startDate: NSDate##NSDate#&gt;)</span></span><br><span class="line">        <span class="comment">// 设定动画的加速和减速方式,或者说是运动节奏...(乱翻的)</span></span><br><span class="line">        UIView.<span class="function"><span class="title">setAnimationCurve</span><span class="params">(UIViewAnimationCurve.EaseInOut)</span></span></span><br><span class="line">        <span class="comment">// 设定动画延迟</span></span><br><span class="line">        UIView.<span class="function"><span class="title">setAnimationDelay</span><span class="params">(<span class="number">0.5</span>)</span></span></span><br><span class="line">        <span class="comment">// 设定动画的时间长度</span></span><br><span class="line">        UIView.<span class="function"><span class="title">setAnimationDuration</span><span class="params">(<span class="number">1.6</span>)</span></span></span><br><span class="line">        <span class="comment">// 设定动画的重复次数</span></span><br><span class="line">        UIView.<span class="function"><span class="title">setAnimationRepeatCount</span><span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line">        <span class="comment">// true设定表示动画每次重复执行的效果跟上一次相反,类似于翻转</span></span><br><span class="line">        UIView.<span class="function"><span class="title">setAnimationRepeatAutoreverses</span><span class="params">(true)</span></span></span><br><span class="line">        <span class="comment">// 设置视图view的过渡效果,</span></span><br><span class="line">        UIView.<span class="function"><span class="title">setAnimationTransition</span><span class="params">(UIViewAnimationTransition.CurlUp, forView: self.view, cache: true)</span></span></span><br><span class="line">        <span class="comment">// 设置代理</span></span><br><span class="line">        UIView.<span class="function"><span class="title">setAnimationDelegate</span><span class="params">(self)</span></span></span><br><span class="line">        <span class="comment">// 动画即将开始的方法</span></span><br><span class="line">        <span class="comment">//UIView.setAnimationWillStartSelector(&lt;#T##selector: Selector##Selector#&gt;)</span></span><br><span class="line">        <span class="comment">//  动画结束后的回调方法</span></span><br><span class="line">        UIView.<span class="function"><span class="title">setAnimationDidStopSelector</span><span class="params">(Selector(<span class="string">"animationDisStop:finished:context:"</span>)</span></span>)</span><br><span class="line">        <span class="comment">// 举个栗子,交换self.view上的两个子视图</span></span><br><span class="line">        self<span class="class">.view</span><span class="class">.exchangeSubviewAtIndex</span>(<span class="number">0</span>, withSubviewAtIndex: <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 标记动画块结束</span></span><br><span class="line">        UIView.<span class="function"><span class="title">commitAnimations</span><span class="params">()</span></span></span><br><span class="line">```  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&lt;<span class="attribute">font</span> <span class="attribute">color</span>=<span class="string">"IndianRed"</span>&gt;Block形式&lt;/<span class="attribute">font</span>&gt;  </span><br><span class="line">`UIView.animateWithDuration`</span><br></pre></td></tr></table></figure></p>
<pre><code>/**
调用最多吧,也是最基本的,配合CALayer的各个属性(例:position)/仿射变换,实现各种动画

:param: &lt;Tduration 动画执行时间
:param: animations 动画执行内容,可以是透明度,移动,旋转,缩放
:param: completion 动画执行完后执行的内容
*/
UIView.animateWithDuration(&lt;#T##duration: NSTimeInterval##NSTimeInterval#&gt;, animations: &lt;#T##() -&gt; Void#&gt;, completion: &lt;#T##((Bool) -&gt; Void)?##((Bool) -&gt; Void)?##(Bool) -&gt; Void#&gt;)
/**
延迟动画,还有一个options属性...好多

:param: &lt;Tduration 动画执行时间
:param: delay          延迟时间
:param: options       一些动画效果的增强枚举
:param: animations  同上
:param: completion  同上
*/
UIView.animateWithDuration(&lt;#T##duration: NSTimeInterval##NSTimeInterval#&gt;, delay: &lt;#T##NSTimeInterval#&gt;, options: &lt;#T##UIViewAnimationOptions#&gt;, animations: &lt;#T##() -&gt; Void#&gt;, completion: &lt;#T##((Bool) -&gt; Void)?##((Bool) -&gt; Void)?##(Bool) -&gt; Void#&gt;)
/**
iOS7之后提供的弹簧化动画

:param: &lt;Tduration                       动画执行时间
:param: delay                                延迟时间
:param: usingSpringWithDamping 弹性阻尼，随着阻尼值越来越接近0.0，动画的弹性效果会越来越明显
:param: initialSpringVelocity         弹簧速率,弹性复位的速度
:param: options                              一些动画效果的增强枚举
:param: animations                         同上
:param: completion                         同上
*/
UIView.animateWithDuration(&lt;#T##duration: NSTimeInterval##NSTimeInterval#&gt;, delay: &lt;#T##NSTimeInterval#&gt;, usingSpringWithDamping: &lt;#T##CGFloat#&gt;, initialSpringVelocity: &lt;#T##CGFloat#&gt;, options: &lt;#T##UIViewAnimationOptions#&gt;, animations: &lt;#T##() -&gt; Void#&gt;, completion: &lt;#T##((Bool) -&gt; Void)?##((Bool) -&gt; Void)?##(Bool) -&gt; Void#&gt;)
</code></pre><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="autohotkey"><span class="escape">`U</span>IView.transitionWithView<span class="escape">`:</span>表示很少用</span></span><br></pre></td></tr></table></figure>
<pre><code>/**
:param: &lt;TfromView 要移除的view
:param: toView     要添加的view
:param: duration   动画执行时间
:param: options    动画转场效果
:param: completion 动画执行完后执行的内容
*/
UIView.transitionFromView(&lt;#T##fromView: UIView##UIView#&gt;, toView: &lt;#T##UIView#&gt;, duration: &lt;#T##NSTimeInterval#&gt;, options: &lt;#T##UIViewAnimationOptions#&gt;, completion: &lt;#T##((Bool) -&gt; Void)?##((Bool) -&gt; Void)?##(Bool) -&gt; Void#&gt;)
/**
:param: &lt;Tview     进行转场的view对象
:param: duration   动画执行时间
:param: options    动画转场效果
:param: animations 动画执行内容
:param: completion 动画执行完后执行的内容
*/
UIView.transitionWithView(&lt;#T##view: UIView##UIView#&gt;, duration: &lt;#T##NSTimeInterval#&gt;, options: &lt;#T##UIViewAnimationOptions#&gt;, animations: &lt;#T##() -&gt; Void#&gt;, completion: &lt;#T##((Bool) -&gt; Void)?##((Bool) -&gt; Void)?##(Bool) -&gt; Void#&gt;)
</code></pre><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="autohotkey"><span class="escape">`U</span>IView.animateKeyframesWithDuration<span class="escape">`:</span>关键帧动画,用来消除各种<span class="escape">`U</span>IView.animateWithDuration<span class="escape">`的</span>嵌套</span></span><br></pre></td></tr></table></figure>
<pre><code>// options这个参数我已经不想看了,不知道apple为什么不用UIViewAnimationOptions
// 动画时间持续6.0秒
UIView.animateKeyframesWithDuration(6.0, delay: 0.0, options: UIViewKeyframeAnimationOptions.CalculationModeLinear, animations: { () -&gt; Void in
    // 第一帧,从0.0开始,持续2.0秒
    UIView.addKeyframeWithRelativeStartTime(0.0, relativeDuration: 2.0, animations: { () -&gt; Void in
        // 要执行的动画
    })
    // 第二帧,从2.0开始,持续2.0秒
    UIView.addKeyframeWithRelativeStartTime(2.0, relativeDuration: 2.0, animations: { () -&gt; Void in
        // 要执行的动画
    })
    // 第三帧,从4.0开始,持续2.0秒
    UIView.addKeyframeWithRelativeStartTime(4.0, relativeDuration: 2.0, animations: { () -&gt; Void in
        // 要执行的动画
    })
    }) { (_) -&gt; Void in
        // 动画执行完之后执行的内容
}
</code></pre><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&lt;<span class="attribute">font</span> <span class="attribute">color</span>=<span class="string">"IndianRed"</span>&gt;N多种类的枚举&lt;/<span class="attribute">font</span>&gt;</span><br><span class="line">`UIViewAnimationCurve`:运动的节奏控制</span><br></pre></td></tr></table></figure>
<p>// 由慢到快<br>UIViewAnimationCurve.EaseInOut<br>// 由慢到特别快<br>UIViewAnimationCurve.EaseIn<br>// 由快到慢<br>UIViewAnimationCurve.EaseOut<br>//匀速,默认<br>UIViewAnimationCurve.Linear<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="escape">`U</span>IViewAnimationTransition<span class="escape">`:</span>视图view的过渡效果</span><br></pre></td></tr></table></figure></p>
<p>// 从左向右翻转,用新视图代替旧视图<br>UIViewAnimationTransition.FlipFromLeft<br>// 从右向左翻转,隐藏旧视图,显示新视图<br>UIViewAnimationTransition.FlipFromRight<br>// 类似翻页…<br>UIViewAnimationTransition.CurlUp<br>// 新视图从上向下盖住旧视图<br>UIViewAnimationTransition.CurlDown<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="escape">`U</span>IViewAnimationOptions<span class="escape">`:</span>当前动画嵌套中的动画执行随时间的快慢种类（先快后慢等..）。动画要一直重复吗。如果我使用转场动画那么我用哪种转场效果。还有子动画嵌套在父动画中时我们如何对待父动画中的相同选项等等..</span><br></pre></td></tr></table></figure></p>
<p>// 提交动画的时候布局子控件，表示子控件将和父控件一同动画。<br>UIViewAnimationOption.LayoutSubviews<br>// 动画时允许用户交流，比如触摸<br>UIViewAnimationOption.AllowUserInteraction<br>// 从当前状态开始动画<br>UIViewAnimationOption.BeginFromCurrentState<br>// 动画无限重复<br>UIViewAnimationOption.Repeat<br>// 执行动画回路,前提是设置动画无限重复<br>UIViewAnimationOption.Autoreverse<br>// 忽略外层动画嵌套的执行时间<br>UIViewAnimationOption.OverrideInheritedDuration<br>// 忽略外层动画嵌套的时间变化曲线<br>UIViewAnimationOption.OverrideInheritedCurve<br>// 通过改变属性和重绘实现动画效果，如果key没有提交动画将使用快照<br>UIViewAnimationOption.AllowAnimatedContent<br>// 用显隐的方式替代添加移除图层的动画效果<br>UIViewAnimationOption.ShowHideTransitionViews<br>// 忽略嵌套继承的选项<br>UIViewAnimationOption.OverrideInheritedOptions<br>// 慢-&gt;快-&gt;慢<br>UIViewAnimationOption.CurveEaseInOut<br>// 慢-&gt;快<br>UIViewAnimationOption.CurveEaseIn<br>// 快-&gt;慢<br>UIViewAnimationOption.CurveEaseOut<br>// 匀速<br>UIViewAnimationOption.CurveLinear<br>// 无转场动画<br>UIViewAnimationOption.TransitionNone<br>// 转场从左翻转<br>UIViewAnimationOption.TransitionFlipFromLeft<br>// 转场从右翻转<br>UIViewAnimationOption.TransitionFlipFromRight<br>// 上卷转场<br>UIViewAnimationOption.TransitionCurlUp<br>// 下卷转场<br>UIViewAnimationOption.TransitionCurlDown<br>// 转场交叉消失<br>UIViewAnimationOption.TransitionCrossDissolve<br>// 转场从上翻转<br>UIViewAnimationOption.TransitionFlipFromTop<br>// 转场从下翻转<br>UIViewAnimationOption.TransitionFlipFromBottom<br>```  </p>
<p><font color="IndianRed">End</font><br>栗子LZ在这里就不举了,实在是太多了…<br>推荐一些资料:  </p>
<blockquote>
<p><a href="http://zsisme.gitbooks.io/ios-/content/index.html" target="_blank" rel="external">iOS Core Animation: Advanced Techniques</a><br><a href="/">iOS Animations by Tutorials</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Start"><a href="#Start" class="headerlink" title="Start"></a><font color="IndianRed">Start</font></h1><p>我们开发App的时候,经常要用到各种动画来实现炫丽效果,本人也十分的喜欢研究动画,所以打算对于<code>动画-Core Animation</code>相关的知识做个梳理与总结.  </p>
<p><code>Core Animation</code>最大好处是可以帮助Mac或者iPhone的开发者减少代码量。因为如果你想用Core Image或者Open GL实现界面的动画特效，其实也是可以的，主要是非常麻烦。而用Core Animation可以极大简化开发难度和减少代码量。</p>
<p><strong>PS:只是对于基础用法和概念进行整理与说明,各种酷炫效果的Demo就靠大家自己去实现了^_^</strong>  </p>
<p>整体的框架结构大致是:<br><img src="http://7qn7zn.com1.z0.glb.clouddn.com/coreAni_0000.jpeg" alt=""></p>
<p><font color="red">第一章</font>先不介绍关键图层<code>CALayer</code>的知识,先来说说<code>UIKit</code>集成在UIView类中的动画API,在我们日常的开发中,UIKit动画API使用起来十分简单与方便,能满足大部分的基本的动画需求.(其实UIKit动画API的底层使用的也是Core Animation,有的时候在你面试的时候,面试官会问你,<code>UIView+animationBlock</code>的方式,是如何实现动画效果的)<br>]]>
    
    </summary>
    
      <category term="基础动画 UIKit封装" scheme="http://hmttommy.com/tags/%E5%9F%BA%E7%A1%80%E5%8A%A8%E7%94%BB-UIKit%E5%B0%81%E8%A3%85/"/>
    
      <category term="CoreAnimation" scheme="http://hmttommy.com/categories/CoreAnimation/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS hitTest-点击事件分发分析]]></title>
    <link href="http://hmttommy.com/2015/05/25/iOS-hitTest/"/>
    <id>http://hmttommy.com/2015/05/25/iOS-hitTest/</id>
    <published>2015-05-25T08:24:51.000Z</published>
    <updated>2015-07-13T13:25:29.000Z</updated>
    <content type="html"><![CDATA[<p>最近朋友问了我个点击事件处理的问题,自己从前也没怎么仔细想过,查过资料才明白是怎么一回事,遂做个小结.<br>写了个小Demo,地址是:<a href="https://github.com/ConanMTHu/HitTestDemo" target="_blank" rel="external">点这里</a><br>先来看一张图:<br><img src="http://7qn7zn.com1.z0.glb.clouddn.com/hittest_01.png" alt=""><br><code>0-1-2</code>代表了他们的层级关系,可见<code>button_1</code>被<code>view_1</code>盖住了,如何透过<code>view_1</code>实现对<code>button_1</code>的点击呢?<br>当时想的就是改<code>userInteractionEnabled = NO</code>(这个属性大家肯定不陌生,<code>UILabel</code>和<code>UIImageView</code>无法接收点击事件就是因为这个属性默认设置为了<code>NO</code>),类似还有<code>Hidden＝YES/alpha&lt;0.01等</code>,虽然可以实现预期点击,但是这样也影响了<code>view_1和他的子视图button_2(无法被点击)</code>.那改怎么做呢?搜了一下,<code>userInteractionEnabled = NO</code>等价于<code>使当前的hitTest：withEvent返回nil</code>,这是个啥? <a id="more"></a> ok,先来看一下<a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html#//apple_ref/doc/uid/TP40009541-CH4-SW4" target="_blank" rel="external">官方文档</a>中对于<code>The Responder Chain Follows a Specific Delivery Path</code>的解释:<br><img src="http://7qn7zn.com1.z0.glb.clouddn.com/hittest_02.png" alt=""><br>那么,UIView是如何判定这个事件是否是自己应该处理的呢？iOS系统检测到一个触摸操作时会打包一个UIEvent对象，并放入Application的队列，Application从队列中取出事件后交给UIWindow来处理，UIWindow会使用hitTest:withEvent:方法来递归的寻找操作初始点所在的view，这个过程成为<code>hit-test view</code>.<br>继续看文档中的说明:<br>The hitTest:withEvent: method returns the hit test view for a given CGPoint and UIEvent. The hitTest:withEvent: method begins by calling the pointInside:withEvent: method on itself. If the point passed into hitTest:withEvent: is inside the bounds of the view, pointInside:withEvent: returns YES. Then, the method recursively calls hitTest:withEvent: on every subview that returns YES.<br>If the point passed into hitTest:withEvent: is not inside the bounds of the view, the first call to the pointInside:withEvent: method returns NO, the point is ignored, and hitTest:withEvent: returns nil. If a subview returns NO, that whole branch of the view hierarchy is ignored, because if the touch did not occur in that subview, it also did not occur in any of that subview’s subviews. This means that any point in a subview that is outside of its superview can’t receive touch events because the touch point has to be within the bounds of the superview and the subview. This can occur if the subview’s clipsToBounds property is set to NO.<br><strong>翻译下,差不多就是:</strong><br>1.首先调用当前视图的pointInside:withEvent:方法判断触摸点是否在当前视图内;<br>2.若pointInside:withEvent:方法返回NO,说明触摸点不在当前视图内,则当前视图的hitTest:withEvent:返回nil.<br>3.若pointInside:withEvent:方法返回YES,说明触摸点在当前视图内,则遍历当前视图的所有子视图(subviews),调用子视图的hitTest:withEvent:方法重复前面的步骤,子视图的遍历顺序是从top到bottom,即从subviews数组的末尾向前遍历,直到有子视图的hitTest:withEvent:方法返回非空对象或者全部子视图遍历完毕.<br>4.若第一次有子视图的hitTest:withEvent:方法返回非空对象,则当前视图的hitTest:withEvent:方法就返回此对象,处理结束;<br>5.若所有子视图的hitTest:withEvent:方法都返回nil,则当前视图的hitTest:withEvent:方法返回当前视图自身(self).  </p>
<p>了解了流程,那么针对文章开头的需求,只需在<code>view_0</code>的hitTest方法里做判断，若touch point是在<code>button_1</code>上，则将<code>button_1</code>作为消息处理对象返回即可:  </p>
<pre><code>override func hitTest(point: CGPoint, withEvent event: UIEvent?) -&gt; UIView? {
    let btn_1_Point = button_1.convertPoint(point, fromView: self)
    guard button_1.pointInside(btn_1_Point, withEvent: event) else {
        return super.hitTest(point, withEvent: event)
    }
    return button_1
}
</code></pre><p>基本告一段落了,最后盗张图,MJ大神的,很直观的解释了:<br><img src="http://7qn7zn.com1.z0.glb.clouddn.com/hittest_003.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近朋友问了我个点击事件处理的问题,自己从前也没怎么仔细想过,查过资料才明白是怎么一回事,遂做个小结.<br>写了个小Demo,地址是:<a href="https://github.com/ConanMTHu/HitTestDemo">点这里</a><br>先来看一张图:<br><img src="http://7qn7zn.com1.z0.glb.clouddn.com/hittest_01.png" alt=""><br><code>0-1-2</code>代表了他们的层级关系,可见<code>button_1</code>被<code>view_1</code>盖住了,如何透过<code>view_1</code>实现对<code>button_1</code>的点击呢?<br>当时想的就是改<code>userInteractionEnabled = NO</code>(这个属性大家肯定不陌生,<code>UILabel</code>和<code>UIImageView</code>无法接收点击事件就是因为这个属性默认设置为了<code>NO</code>),类似还有<code>Hidden＝YES/alpha&lt;0.01等</code>,虽然可以实现预期点击,但是这样也影响了<code>view_1和他的子视图button_2(无法被点击)</code>.那改怎么做呢?搜了一下,<code>userInteractionEnabled = NO</code>等价于<code>使当前的hitTest：withEvent返回nil</code>,这是个啥?]]>
    
    </summary>
    
      <category term="hit-test" scheme="http://hmttommy.com/tags/hit-test/"/>
    
      <category term="事件传递" scheme="http://hmttommy.com/categories/%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Autolayout优秀的第三方开源库]]></title>
    <link href="http://hmttommy.com/2015/04/14/AutolayoutDetail/"/>
    <id>http://hmttommy.com/2015/04/14/AutolayoutDetail/</id>
    <published>2015-04-14T08:20:21.000Z</published>
    <updated>2015-08-15T13:07:58.000Z</updated>
    <content type="html"><![CDATA[<p>最近项目开始用纯代码布局整个UI框架, 对于前一段很长时间都是xib+storyboard狂拖控件约束的我来说,每天写的代码量剧增…对于<code>sb好还是纯代码好的争论</code>,可以参考下<a href="http://blog.devtang.com/blog/2015/03/22/ios-dev-controversy-2/" target="_blank" rel="external">巧大大的分析</a>.<br>说到UI适配布局,一般有两种方法:  </p>
<ul>
<li>frame,利用<code>[UIScreen mainScreen].bounds.size.width/height</code>,一个一个的算出对应frame,结果肯定是OK的,只是过程异常的痛苦,尤其像我这种语文老师教的数学的小学生.囧.  </li>
<li>autolayout,相信肯定是主流布局,而且对于UI设计师给我的效果图,也是很方便我们直接拿来进行约束设值,无须其他任何计算.    </li>
</ul>
<p>这里主要介绍手写autolayout约束,由于系统提供的api写起来<code>又臭又长</code>,推荐一个不错的第三方.<br>OC版本对应的是<code>Masonry</code>,Swift版本对应的是<code>SnapKit</code>.当然还有其他优秀的autolayout相关第三方,会在结尾给出,感兴趣的朋友可以去研究下,LZ主要用<code>Masonry</code>(大爱这种链式语法)^_^!  </p>
<p>#<font color="IndianRed">Masonry</font><br>Github地址是:<a href="https://github.com/SnapKit/Masonry" target="_blank" rel="external">Masonry</a><br>具体用法github上已经讲的很清楚了,可以下载Demo看看栗子的实现,总结一下我在使用过程中了解.  </p>
<ul>
<li><code>mas_makeConstraints</code>使用最多,做初始约束,只负责新增约束</li>
<li><code>mas_updateConstraints</code>针对<code>make</code>中的约束做更新,一般不添加新约束,只是对于原约束数值的修改.  </li>
<li><code>mas_remakeConstraints</code>清除之前所有的约束,采用里面设置的最新约束,常用于动画之后新位置的约束设定  </li>
<li>优先级高<code>.priorityHigh</code>,优先级低<code>.priorityLow</code>,通常用于根据条件判断来设定优先响应哪种约束  </li>
<li><code>multipliedBy(x)</code>= *x,<code>dividedBy(x)</code> = /x  </li>
<li><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">        make.edges.mas_equalTo(UIEdgeInsetsMake(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>));</span><br><span class="line">        <span class="comment">// edges就是相当于top-left-bottom-right</span></span><br><span class="line">        <span class="comment">// top和left里的offset为正数</span></span><br><span class="line">        <span class="comment">// 那么为什么bottom和right里的offset是负数呢? 因为这里计算的是绝对的数值 计算的bottom需要小于sv的底部高度 所以要-10 同理用于right</span></span><br><span class="line">        <span class="comment">// 有意思的地方是and和with 其实这两个函数什么事情都没做,可以省略的</span></span><br><span class="line">        </span><br><span class="line">        /* 等价于</span><br><span class="line">         make.top.equalTo(weakSelf.<span class="built_in">sv</span>).with.offset(<span class="number">10</span>);</span><br><span class="line">         make.left.equalTo(weakSelf.<span class="built_in">sv</span>).with.offset(<span class="number">10</span>);</span><br><span class="line">         make.bottom.equalTo(weakSelf.<span class="built_in">sv</span>).with.offset(-<span class="number">10</span>);</span><br><span class="line">         make.right.equalTo(weakSelf.<span class="built_in">sv</span>).with.offset(-<span class="number">10</span>);</span><br><span class="line">         */</span><br><span class="line">```  </span><br><span class="line">&lt;!--more--&gt;  </span><br><span class="line">* `UIScrollView`是一个有点特殊的<span class="built_in">view</span>,对于在里面放其他<span class="built_in">view</span>,最好的做法是先放一个`containerView`设置`edges`相等,然后在此<span class="built_in">view</span>上添加subview.  </span><br><span class="line">* 模仿系统的UITabBarController的底部View,可以设定个数和间隔:</span><br></pre></td></tr></table></figure>
<ul>
<li><p>(void)simulateSystemTabBarWithButtonCount:(NSInteger)count withSpace:(CGFloat)space {<br>[self.view showPlaceHolder];<br>self.view.backgroundColor = [UIColor grayColor];<br>NSMutableArray *viewArray = [NSMutableArray arrayWithCapacity:10];</p>
<p>for (int i = 0; i &lt; count; i++) {</p>
<pre><code>UIView *view = [UIView new];
view.backgroundColor = [UIColor colorWithHue:( arc4random() % 256 / 256.0 )
                                  saturation:( arc4random() % 128 / 256.0 ) + 0.5
                                  brightness:( arc4random() % 128 / 256.0 ) + 0.5
                                       alpha:1];;
[view showPlaceHolder];
[self.view addSubview:view];
[viewArray addObject:view];
</code></pre><p>}<br>UIView *lastView = viewArray.lastObject;<br>for (int i = 0; i &lt; count; i++) {</p>
<pre><code>UIView *view = (UIView *)viewArray[i];
[view mas_makeConstraints:^(MASConstraintMaker *make) {
    make.bottom.equalTo(view.superview);
    make.height.equalTo(@49);
    make.width.equalTo(lastView);
    if (i == 0) {
        make.left.mas_equalTo(view.superview).offset(space);
    } else {
        UIView *frontView = (UIView *)viewArray[i-1];
        make.left.equalTo(frontView.mas_right).offset(space);
        (i == viewArray.count - 1) ? make.right.mas_equalTo(view.superview).offset(-space) : nil;
    }
}];
</code></pre><p>}<br>}<br>```<br>以count = 4 和 space =0  为例子<br><img src="http://7qn7zn.com1.z0.glb.clouddn.com/338E3FB7-40B3-40C3-9208-BD6554E61960.png" alt="">  </p>
</li>
</ul>
</li>
<li>实现动画时,更新约束后调用<code>layoutIfNeeded</code>  </li>
<li>最后,再次强调真的非常好用!!!  </li>
</ul>
<p>#<font color="IndianRed">SnapKit</font><br>Github地址:<a href="https://github.com/SnapKit/SnapKit" target="_blank" rel="external">SnapKit</a><br><strong>PS:目前只支持swift1.2版本,在最新的xcode7-swift2.0中会报错,我在推特上问了作者,他说最近略忙,暂时没空…囧…有兴趣的朋友可以自己改下让它支持2.0然后pull…我?还在研究中.</strong><br>这个就不过多举例了,基本就是跟<code>Masonry</code>一样,而且我在后面的Demo基本都是用了<code>Snapkit</code>来写(xcode7上我是拖控件…没办法,谁让还不支持2.0)<br>举个栗子-&gt;最常见的上下两个button:<br><img src="http://7qn7zn.com1.z0.glb.clouddn.com/AUTOLAYOUTdeTAIL.png" alt="">  </p>
<p>#<font color="IndianRed">其他资料</font>  </p>
<ul>
<li>autolayout其他第三方开源库  <blockquote>
<p><a href="https://github.com/smileyborg/PureLayout" target="_blank" rel="external">PureLayout</a><br><a href="https://github.com/smileyborg/UIView-AutoLayout" target="_blank" rel="external">UIView-AutoLayout</a><br><a href="https://github.com/adad184/MMPlaceHolder" target="_blank" rel="external">MMPlaceHolder 这个是辅助工具 一个显示宽*高的插件</a><br><a href="https://github.com/robb/Cartography" target="_blank" rel="external">Cartography for swift</a>  </p>
</blockquote>
</li>
</ul>
<ul>
<li>博文  <blockquote>
<p><a href="http://www.cocoachina.com/industry/20131012/7148.html" target="_blank" rel="external">先进的自动布局工具箱</a><br><a href="http://www.vienta.me/2014/12/07/AutoLayout-%E5%BF%98%E6%8E%89Frame-%E6%8B%A5%E6%8A%B1Constraint%EF%BC%88I%EF%BC%89/" target="_blank" rel="external">AutoLayout:忘掉Frame,拥抱Constraint</a><br><a href="https://www.zybuluo.com/MicroCai/note/73867#autolayout-基础" target="_blank" rel="external">Autolayout 基础</a><br><a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG/Introduction/Introduction.html" target="_blank" rel="external">Auto Layout Guide 官方</a><br><a href="http://adad184.com/2014/09/28/use-masonry-to-quick-solve-autolayout/" target="_blank" rel="external">Masonry介绍与使用实践(快速上手Autolayout)</a><br><a href="http://tutuge.me/2015/05/23/autolayout-example-with-masonry/" target="_blank" rel="external">有趣的Autolayout示例-Masonry实现</a><br><a href="http://onevcat.com/2012/09/autoayout/" target="_blank" rel="external">喵神的Autolayout介绍</a><br><a href="http://www.cocoachina.com/ios/20150104/10817.html" target="_blank" rel="external">如何在Objective-C中实现链式语法？</a>  </p>
</blockquote>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近项目开始用纯代码布局整个UI框架, 对于前一段很长时间都是xib+storyboard狂拖控件约束的我来说,每天写的代码量剧增…对于<code>sb好还是纯代码好的争论</code>,可以参考下<a href="http://blog.devtang.com/blog/]]>
    </summary>
    
      <category term="AutoLayout" scheme="http://hmttommy.com/tags/AutoLayout/"/>
    
      <category term="第三方库" scheme="http://hmttommy.com/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[设计模式(二)之策略模式]]></title>
    <link href="http://hmttommy.com/2015/04/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%8C-%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://hmttommy.com/2015/04/01/设计模式-二-之策略模式/</id>
    <published>2015-04-01T00:41:23.000Z</published>
    <updated>2015-05-27T06:03:44.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u521D_u5165_u6C5F_u6E56"><a href="#u521D_u5165_u6C5F_u6E56" class="headerlink" title="初入江湖"></a><font color="IndianRed">初入江湖</font></h1><p><strong>策略模式</strong>：定义一系列的算法,把每一个算法封装起来, 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化.<br>0.0好吧,基本上所有介绍策略模式的基本都是这样的开头,详情概念可见<a href="http://baike.baidu.com/link?url=K31Rsj_er4saTaz4l0L69f6YxCMbVTnR9KO007RcP4ymkNGqhvABAtWb3o038qrgLOmVJJOxV08HZVh3HfRTGK" target="_blank" rel="external">策略模式百度百科</a>!博主最初用它,除了善用设计模式优化代码结构之外,最主要的就是消除万恶的<code>if else</code>或<code>switch case</code>(很讨厌<code>if else</code>…在写代码的时候能够用<code>? :</code>就用)<br>话不多说,先来张图(盗的,勿喷,^_^):<br><img src="http://hmtphoto.qiniudn.com/strategy_001.jpg" alt="">  </p>
<h1 id="u5C0F_u8BD5_u624B_u5200"><a href="#u5C0F_u8BD5_u624B_u5200" class="headerlink" title="小试手刀"></a><font color="IndianRed">小试手刀</font></h1><p>我举得栗子概念是<a href="http://casatwy.com/iosying-yong-jia-gou-tan-viewceng-de-zu-zhi-he-diao-yong-fang-an.html" target="_blank" rel="external">iOS应用架构谈 view层的组织和调用方案</a>(<strong>强烈推荐此文,很长但是涉及到了很多知识点</strong>)中谈到的文件<code>聊天应用的消息发送模块</code>  </p>
<ul>
<li>定义一个<code>Context</code>类,里面有一个<code>RootStrategy</code>属性  <figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">enum MessageSendStrategyType &#123;</span><br><span class="line">    case Text</span><br><span class="line">    case Image</span><br><span class="line">    case Voice</span><br><span class="line">    case Video</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="label">class StrategyContext:</span> NSObject &#123; </span><br><span class="line"><span class="label">    var strategy:</span> RootStrategy?</span><br><span class="line">    // oc 则是 [TextSendStrategy class]....</span><br><span class="line"><span class="label">    let strategyClassDic: [MessageSendStrategyType : AnyClass] = [MessageSendStrategyType.Text : TextSendStrategy.self, .Image : ImageStrategy.self, .Voice : VoiceStrategy.self, .Video :</span> VideoStrategy.self]<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line"><span class="label">//    let strategyStringDic: [MessageSendStrategyType : String] = [MessageSendStrategyType.Text :</span> <span class="string">"StrategyMode.TextSendStrategy"</span>, .Image : <span class="string">"StrategyMode.ImageStrategy"</span>, .Voice : <span class="string">"StrategyMode.VoiceStrategy"</span>, .Video : <span class="string">"StrategyMode.VideoStrategy"</span>]<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="label">    init(messageType :</span> MessageSendStrategyType) &#123;</span><br><span class="line"><span class="label">        let strategyClassClass:</span> AnyClass? = strategyClassDic[messageType]</span><br><span class="line">        strategy = (strategyClassClass! as! RootStrategy.Type)()</span><br><span class="line">        </span><br><span class="line"><span class="label">//        let strategyStringClass:</span> AnyClass! = NSClassFromString(strategyStringDic[messageType]!)</span><br><span class="line">//        self.strategy = (strategyStringClass as! RootStrategy.Type).new()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func contextInterface() &#123;</span><br><span class="line">        strategy!.run()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="escape">``</span><span class="escape">` </span> </span><br><span class="line"><span class="number">1</span>.定义一个<span class="escape">`M</span>essageSendStrategyType<span class="escape">`枚</span>举<span class="escape">`+</span><span class="escape">`反</span>射,解决内部/外部的<span class="escape">`s</span>witch case<span class="escape">`的</span>构建工厂(见工厂模式)判断  </span><br><span class="line"><span class="number">2</span>.给字典赋值的两种方式都行,但注意调用<span class="escape">`N</span>SClassFromString<span class="escape">`的</span>时候有坑,单纯的传<span class="escape">`类</span>名<span class="escape">`无</span>效,需要加上你的工程名,我的工程名是<span class="escape">`S</span>trategyMode<span class="escape">`,</span>那就必须是<span class="escape">`N</span>SClassFromString(StrategyMode.xxxx)<span class="escape">`才</span>行!!!  </span><br><span class="line"><span class="number">3</span>.调用<span class="escape">`n</span>ew()<span class="escape">`和</span><span class="escape">`(</span>)<span class="escape">`初</span>始化是不一样的,后面会给出说明  </span><br><span class="line"> &lt;!--more--&gt;  </span><br><span class="line">  </span><br><span class="line">- 接着定义<span class="escape">`R</span>ootStrategy<span class="escape">`,</span>也就是所有<span class="escape">`算</span>法<span class="escape">`的</span>父类/公共接口</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>@objc protocol SendFunctionDelegate: NSObjectProtocol {<br>    func strategyMsg()<br>    optional func sendReadyData()<br>    optional func uploadRequest(name: String?) -&gt; String?<br>    optional func uploadResource(id: String?, data: NSData?) -&gt; String?<br>    optional func otherMethod_A()<br>    optional func otherMethod_B()<br>}</p>
<p>class RootStrategy: NSObject{</p>
<pre><code>var delegate: SendFunctionDelegate?
required  override init() {
}
/**
*   多态的体现,父类的这个方法必须要子类去覆重,可以不写在接口,直接定义为父类的方法
*   不过这里通过IOP,定义这类方法为`required`必须实现的
*   这里通过接口方式而不是全部多态(好纠结,我表示运用的不熟练吧,反正我自己也没能完全说服自己)
*   总感觉试验失败了,囧!!!
*/
// 被我改来改去,达到所谓的消除父类的空方法....
func run() {
    self.delegate!.strategyMsg()
}
</code></pre><p>//    如果不实现strategyMsg(),就会报错,无法调用<br>//    func run() {<br>//        delegate!.strategyMsg()<br>//    }<br>}</p>
<p>/** 喵神的tip里面说到了 为什么要添加这样一个初始化方法</p>
<ul>
<li>单单是这样还是无法通过编译,编译器提示我们如果想要构建一个 Self 类型的对象的话,需要有 required 关键字修饰的初始化方 法,这是因为 Swift 必须保证 当前类和其子类都能响应这个 init 方法</li>
<li>required 要求必须要实现,但又因为init()是默认的构造器,子类会默认实现并且默认调用,required的关键就是会强制调用默认构造器<br>*/</li>
</ul>
<p>/**</p>
<ul>
<li>不过,如果你在Context中的初始化是用了<code>new()</code>就不需要实现下面方法</li>
<li>官方文档: This method is a combination of alloc and init. Like alloc, it initializes the isa instance variable of the new object so it points to the class data structure. It then invokes the init method to complete the initialization process.</li>
<li><p>所以,不需要你强制,子类也一定会做<code>init()</code>操作<br>*/<br>//    required override init() {<br>//<br>//    }</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS:这里也踩了很多坑<span class="attribute">...</span>一直在试验我前面提到文章里面说的<span class="string">`接口代替继承`</span>,貌似没成功,swift中对于<span class="string">`protocol`</span>和oc中有那么点不一样<span class="attribute">...</span>反正写乱了<span class="attribute">...</span>还是直接把方法直接写父类吧<span class="attribute">...</span>  </span><br><span class="line">  </span><br><span class="line">  - 然后就是<span class="string">`Strategy`</span>的具体实现了,如<span class="string">`TextSendStrategy`</span> <span class="string">`ImageStrategy`</span>  <span class="string">`VoiceStrategy`</span>  <span class="string">`VideoStrategy`</span>,暂举<span class="number">2</span>个栗子:</span><br></pre></td></tr></table></figure>
<p>// 文本<br>class TextSendStrategy: RootStrategy,SendFunctionDelegate {<br>required  init() {</p>
<pre><code>super.init()
self.delegate = self
</code></pre><p>}</p>
<p>func strategyMsg() {</p>
<pre><code>sendReadyData()
</code></pre><p>}</p>
<p>func sendReadyData() {</p>
<pre><code>println(&quot;文本消息,直接发送&quot;)
</code></pre><p>}<br>}</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>
<p>// 图片<br>class ImageStrategy: RootStrategy,SendFunctionDelegate {</p>
<p>required  init() {</p>
<pre><code>super.init()
self.delegate = self
</code></pre><p>}</p>
<p> func strategyMsg() {</p>
<pre><code>let id = uploadRequest(&quot;123456&quot;)
let url = uploadResource(id, data: nil)
sendReadyData()
</code></pre><p>}</p>
<p>func uploadRequest(name: String?) -&gt; String? {</p>
<pre><code>println(&quot;ID申请好了&quot;)
return &quot;ID&quot;
</code></pre><p>}</p>
<p>func uploadResource(id: String?, data: NSData?) -&gt; String? {</p>
<pre><code>println(&quot;URL也得到了&quot;)
return &quot;URL&quot;
</code></pre><p>}</p>
<p>func  sendReadyData() {</p>
<pre><code>println(&quot;可以发送图片了&quot;)
</code></pre><p>}<br>}</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="code"> </span></span><br><span class="line"><span class="code"> </span></span><br><span class="line"><span class="bullet">- </span>最后调用</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>override func viewDidLoad() {<br>        super.viewDidLoad()<br>        // Do any additional setup after loading the view, typically from a nib.<br>        // video,text,voice,image随便传,要什么传什么<br>        let context = StrategyContext(messageType: .Image)<br>        context.contextInterface()</p>
<pre><code>}
</code></pre><p>```  </p>
<h1 id="u5C0F_u529F_u544A_u6210"><a href="#u5C0F_u529F_u544A_u6210" class="headerlink" title="小功告成"></a><font color="IndianRed">小功告成</font></h1><p>一个简单的策略模式Demo,基本就这样完成了.这样,是不是,即使存在各种类型的数据发送判断,也没有出现一个<code>if else</code>或<code>switch case</code>呀!<br>LZ最近的两个项目里面都用到了:<br>一是.文件传送,接受来自底层返回的各种类型数据,需要对应各自的数据处理方法<br>二是.网络请求,同栗子….</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u521D_u5165_u6C5F_u6E56"><a href="#u521D_u5165_u6C5F_u6E56" class="headerlink" title="初入江湖"></a><font color="IndianRed">初入江湖</font><]]>
    </summary>
    
      <category term="策略" scheme="http://hmttommy.com/tags/%E7%AD%96%E7%95%A5/"/>
    
      <category term="设计模式" scheme="http://hmttommy.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS面试题总结与感想]]></title>
    <link href="http://hmttommy.com/2015/03/21/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%E4%B8%8E%E6%84%9F%E6%83%B3/"/>
    <id>http://hmttommy.com/2015/03/21/iOS面试题总结与感想/</id>
    <published>2015-03-21T10:15:21.000Z</published>
    <updated>2015-03-21T15:36:12.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u9898"><a href="#u9898" class="headerlink" title="题"></a><font color="IndianRed">题</font></h3><p>必须先吐槽一下,找工作面试确实是个累人的活呀,所以—&gt;<code>跳槽有风险,选择需谨慎</code>.LZ我为什么要换工作呢?就不在这里说明了…直接进入正题,这周的面试基本每天从早面到晚,面试表都填吐了…大小公司都有,列举下这段时间常见的面试题和一些个人理解.PS:LZ我水平有限,不好的地方,大家轻喷^_^!(因为完全是靠记忆,列举顺序纯凭感觉0.0)  </p>
<ol>
<li><code>@property</code>中的assign,retain,copy,nonatomic的意思分别是什么? (解释略…你懂的)</li>
<li><code>weak</code>和<code>assign</code>的区别,<code>strong</code>和<code>retain</code>的区别,<code>copy</code>和<code>retain</code>的区别?<br><code>assign</code>适用于非对象类型,<code>weak</code>弱引用在引用计数为0的时候会将对象置为nil.<br>其实从这个也可以引申到内存管理的一系列问题.面试官会让你讲讲<code>MRC</code>和<code>ARC</code>的理解,随即也引申出<code>Block</code>的内存机制,为啥推荐<code>Block</code>用<code>copy</code>,<code>Block</code>会存在哪些内存问题?循环引用?<br>推荐一个文章,讲的蛮不错的,里面也有对<code>Block</code>的链接引用-&gt;<a href="http://www.cocoachina.com/ios/20150206/11121.html#0-qzone-1-7097-d020d2d2a4e8d1a374a433f596ad1440" target="_blank" rel="external">传送门,请点击我</a></li>
<li>依旧是内存管理,<code>release</code>和<code>autorelease</code>的含义?这里尤其要强调下<code>autorelease</code>,它引申出<code>自动释放池</code>,也能引申出<code>Run loop</code>!<br>参考下这两个链接:<a href="http://blog.csdn.net/yanfangjin/article/details/7545673" target="_blank" rel="external">参考1号</a>@<a href="http://stackoverflow.com/questions/5766839/end-of-run-loop-autorelease-pool-recovery" target="_blank" rel="external">参考2号</a>(<font color="red">PS:有的链接可能需要翻墙,但是作为一个开发人员来说,    拥有VPN进行google还是必备的吧!</font>)</li>
<li>OC语言的动态性指什么?有没有了解过<code>objective-c runtime</code>的相关问题?它包括那些含义?<br>依旧给出一些不错的文章链接:<a href="http://southpeak.github.io/blog/2014/10/25/objective-c-runtime-yun-xing-shi-zhi-lei-yu-dui-xiang/" target="_blank" rel="external">Number1</a>@<a href="http://blog.codingcoder.com/dig-into-objc/" target="_blank" rel="external">Number2</a>@<a href="http://chun.tips/" target="_blank" rel="external">Number3</a></li>
<li>使用过<code>Core Graphic</code> <code>Core Animation</code> <code>Quartz Core</code>等常用框架吗?在什么条件下会用到?能够实现什么功能?一般这种问题,都是涉及到你自定义UI控件的能力,以及能够实现炫丽动画效果的能力.(含义很广,大家自行找资料,还是推荐个0.0-&gt;<a href="http://zsisme.gitbooks.io/ios-/content/index.html" target="_blank" rel="external">讲Core Animation的</a>)</li>
<li>iOS中多线程有哪几种?各自之间有什么区别?这个问题,毋庸置疑,必问!!!<br><code>NSThread</code>:貌似基本没到过…囧….可以去了解下….<br><code>NSOperation</code>:据说是用在处理复杂的情况下…经常被问到与<code>GCD</code>的不同,LZ略纠结每次都不知道怎么回答,只能说一个处理复杂情况一个处理简单情况…也没用到过…不过你研究下<code>AFNetworking</code>的源码,可以发现,它的核心类是继承<code>NSOperation</code>的…<br><code>GCD</code>:常用…这个可以看看我的博客,里面很多它的介绍! <a href="http://blog.csdn.net/hmt20130412/article/category/2206439" target="_blank" rel="external">点这里</a></li>
<li>数据存储这一块,你常用哪一种?什么是<code>序列化</code>?<code>sqlite</code>是直接用它还是用封装了它的第三方库?<code>sqlite</code>和<code>core data</code>的区别?<br>LZ碰到的基本都是问<code>sqlite</code>和<code>core data</code>的区别…从什么方面来决定一个项目采用哪种方式来做存储…个人觉得没有必要区分谁好谁坏…都去了解掌握肯定是有好处的…网上有很多讲两个之间的区别,但是就算你知道区别,如果两个都用不好也是白搭.唯有一解-&gt;<code>学!学!学</code><a id="more"></a></li>
<li><code>代理</code>和<code>通知</code>…分别在什么情况下使用?区别?各自优点?(略,略,略,自行谷歌)</li>
<li>你经常使用一些第三方库吗?比如<code>AFNetworking</code> <code>SDWebimage</code> <code>JsonModel</code>等,有没有去了解过里面的实现原理?<br>强烈推荐大家,最好都去看看源代码,不要<code>只知其而不知其所以然</code>,能够学习到很多知识.也算是一次整体知识架构的温习,也能学习到一些优秀库的设计模式等.</li>
<li><code>KVC</code>和<code>KVO</code>是什么?</li>
<li>是否了解<code>Socket网络编程</code>?是否明白<code>TCP/IP</code> <code>HTTP</code> <code>UDP</code>等协议知识?<br><a href="http://blog.sina.com.cn/s/blog_8dabcad30101ozhg.html" target="_blank" rel="external">参考1号</a>@<a href="http://www.cnblogs.com/li0803/archive/2008/11/03/1324746.html" target="_blank" rel="external">参考2号</a>…很多,自己去找吧</li>
<li>你知道哪些<code>设计模式</code>?实际项目中运用到了吗?(LZ我只回答了,<code>单例-策略-观察者-工厂-代理</code>(其实我觉得代理不能算进去))</li>
<li><code>MVC</code>是什么?你能画出它们之间的关系图吗?(对的,画图)</li>
<li>你的<code>C++</code>如何?<code>算法和数据结构</code>呢?(这个都是泪呀)-&gt;依旧是补!补!补!</li>
<li><code>Autolayout</code>的理解…使用的怎么样?<a href="http://www.hmttommy.com/2014/12/05/AutoLayout/" target="_blank" rel="external">可以看看我的这篇…虽然没详细讲Autolayout</a>…大家可以多搜搜…这就是涉及到你写代码是<code>纯代码</code>还是<code>storyboard</code>了…建立两种都必须掌握.</li>
<li>有没有学习<code>Swift</code>?这个,LZ建议,毕竟苹果给你开发的框架库没变,可以拿它写写Demo保持认识度,要不然,你只看不写,过一段时间又把它忘记了,就白看了…亲身体会…起码我现在能用<code>swift</code>来写写一些Demo就用它来写写….工作肯定还是用OC啦,不过也有的公司说已经完全用<code>swift</code>来开发了,只能说,毕竟还只是很少数的…</li>
<li>目前暂时想到这些…如果还有,再更新!0.0  </li>
</ol>
<h3 id="u60F3"><a href="#u60F3" class="headerlink" title="想"></a><font color="IndianRed">想</font></h3><p>说下面试的感想吧:  </p>
<ul>
<li>并不是会写OC,会调用API,你就是一个iOS开发工程师了…你必须扩展你知识的广度和深度,对于很多招聘要求你会C++的时候,不要老想着自己是来应聘iOS工程师而不是C++工程师…语言只是一种工具,当你功力OK的时候,你会发现去学习一门语言没有你想象的那么难,只能说要精通是略难的…很多时候需要的是你有那么一种概念,比如你项目中需要去调用一个库,那个库是C++写的,如果你完全看不懂,咋办…这也就是说并不是要你自己完全的去写一个出来…我们开发的很多时候,都是要善于运用第三方的框架…再举个例子,音频视频…解码转码或者什么什么的,具体的东西可能不需要你去了解,你只需要会使用一种工具(如:<code>ffmpeg</code>)来完成它.  </li>
<li>LZ我就像我上面说的那样…惭愧呀…不过算是从学<code>swift</code>后,换了一种思想,不再那样的去排斥语言间的不同了,觉得自己也要在平时有空闲的时候,认真的学习下<code>c++</code>(其实我以前是想做游戏的…还说自学<code>cocos2dx</code>),也可以把大学里面有关计算机网络的书籍再次看下,多了解下网络编程…TCP/IP…HTTP协议等.  </li>
<li>开发应用,不要只停留在一个方向…多横向发展,接触下其他类型的应用.比如,我找工作就有意于<code>IM</code> <code>音频视频</code>等,毕竟没接触过…但是这只是个人意愿,前提别人肯要我,0.0哭0.0  </li>
<li>切记好高骛远,一步登天…技术需要沉淀,心态需要淡定,什么时候都要虚心学习.前面我说的都是建立在你做好基本事情的基础上…想想,啥都不精,没有一技之长,怎么能脱颖而出?怎么能够完成你所在岗位的任务?iOS开发这一块的知识也要保持不断的学习…UI布局-动画效果-逻辑控制-数据存储-和各端的对接-整体架构.  </li>
<li>公司的项目应该所有的都是结果导向性,如果你完成不了任务,那么你完成任务过程中所有的出彩点都会变得一无是处.    </li>
<li>依旧暂时想到这些…再想到别的,再更新…待续.<strong>~O(∩_∩)O~</strong>  </li>
</ul>
<p><img src="http://hmtphoto.qiniudn.com/面试励志图.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u9898"><a href="#u9898" class="headerlink" title="题"></a><font color="IndianRed">题</font></h3><p>必须先吐槽一下,找工作面试确实是个累人的活呀,所以—&gt;<code>跳槽有风险,选择需谨慎</code>.LZ我为什么要换工作呢?就不在这里说明了…直接进入正题,这周的面试基本每天从早面到晚,面试表都填吐了…大小公司都有,列举下这段时间常见的面试题和一些个人理解.PS:LZ我水平有限,不好的地方,大家轻喷^_^!(因为完全是靠记忆,列举顺序纯凭感觉0.0)  </p>
<ol>
<li><code>@property</code>中的assign,retain,copy,nonatomic的意思分别是什么? (解释略…你懂的)</li>
<li><code>weak</code>和<code>assign</code>的区别,<code>strong</code>和<code>retain</code>的区别,<code>copy</code>和<code>retain</code>的区别?<br><code>assign</code>适用于非对象类型,<code>weak</code>弱引用在引用计数为0的时候会将对象置为nil.<br>其实从这个也可以引申到内存管理的一系列问题.面试官会让你讲讲<code>MRC</code>和<code>ARC</code>的理解,随即也引申出<code>Block</code>的内存机制,为啥推荐<code>Block</code>用<code>copy</code>,<code>Block</code>会存在哪些内存问题?循环引用?<br>推荐一个文章,讲的蛮不错的,里面也有对<code>Block</code>的链接引用-&gt;<a href="http://www.cocoachina.com/ios/20150206/11121.html#0-qzone-1-7097-d020d2d2a4e8d1a374a433f596ad1440">传送门,请点击我</a></li>
<li>依旧是内存管理,<code>release</code>和<code>autorelease</code>的含义?这里尤其要强调下<code>autorelease</code>,它引申出<code>自动释放池</code>,也能引申出<code>Run loop</code>!<br>参考下这两个链接:<a href="http://blog.csdn.net/yanfangjin/article/details/7545673">参考1号</a>@<a href="http://stackoverflow.com/questions/5766839/end-of-run-loop-autorelease-pool-recovery">参考2号</a>(<font color="red">PS:有的链接可能需要翻墙,但是作为一个开发人员来说,    拥有VPN进行google还是必备的吧!</font>)</li>
<li>OC语言的动态性指什么?有没有了解过<code>objective-c runtime</code>的相关问题?它包括那些含义?<br>依旧给出一些不错的文章链接:<a href="http://southpeak.github.io/blog/2014/10/25/objective-c-runtime-yun-xing-shi-zhi-lei-yu-dui-xiang/">Number1</a>@<a href="http://blog.codingcoder.com/dig-into-objc/">Number2</a>@<a href="http://chun.tips/">Number3</a></li>
<li>使用过<code>Core Graphic</code> <code>Core Animation</code> <code>Quartz Core</code>等常用框架吗?在什么条件下会用到?能够实现什么功能?一般这种问题,都是涉及到你自定义UI控件的能力,以及能够实现炫丽动画效果的能力.(含义很广,大家自行找资料,还是推荐个0.0-&gt;<a href="http://zsisme.gitbooks.io/ios-/content/index.html">讲Core Animation的</a>)</li>
<li>iOS中多线程有哪几种?各自之间有什么区别?这个问题,毋庸置疑,必问!!!<br><code>NSThread</code>:貌似基本没到过…囧….可以去了解下….<br><code>NSOperation</code>:据说是用在处理复杂的情况下…经常被问到与<code>GCD</code>的不同,LZ略纠结每次都不知道怎么回答,只能说一个处理复杂情况一个处理简单情况…也没用到过…不过你研究下<code>AFNetworking</code>的源码,可以发现,它的核心类是继承<code>NSOperation</code>的…<br><code>GCD</code>:常用…这个可以看看我的博客,里面很多它的介绍! <a href="http://blog.csdn.net/hmt20130412/article/category/2206439">点这里</a></li>
<li>数据存储这一块,你常用哪一种?什么是<code>序列化</code>?<code>sqlite</code>是直接用它还是用封装了它的第三方库?<code>sqlite</code>和<code>core data</code>的区别?<br>LZ碰到的基本都是问<code>sqlite</code>和<code>core data</code>的区别…从什么方面来决定一个项目采用哪种方式来做存储…个人觉得没有必要区分谁好谁坏…都去了解掌握肯定是有好处的…网上有很多讲两个之间的区别,但是就算你知道区别,如果两个都用不好也是白搭.唯有一解-&gt;<code>学!学!学</code>]]>
    
    </summary>
    
      <category term="面试题" scheme="http://hmttommy.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="随笔" scheme="http://hmttommy.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift AVFoundation 二维码扫描和生成]]></title>
    <link href="http://hmttommy.com/2015/03/16/Swift-AVFoundation-%E4%BA%8C%E7%BB%B4%E7%A0%81%E6%89%AB%E6%8F%8F%E5%92%8C%E7%94%9F%E6%88%90/"/>
    <id>http://hmttommy.com/2015/03/16/Swift-AVFoundation-二维码扫描和生成/</id>
    <published>2015-03-16T00:46:28.000Z</published>
    <updated>2015-06-26T06:51:32.000Z</updated>
    <content type="html"><![CDATA[<p>项目终于不需要支持iOS6了(泪崩),在二维码扫描这一块,能够完全的放弃<code>ZXing</code>库,改用系统的<code>AVFoundation</code>了,拿<code>swift</code>写了个Demo,效果如下:<br><strong>github地址:<a href="https://github.com/ConanMTHu/QRCodeByAVFoundation" target="_blank" rel="external">点这里</a></strong><br><img src="http://7qn7zn.com1.z0.glb.clouddn.com/qrcode_1.PNG" alt="">  </p>
<p>有关<code>AVFoundation</code>和<code>Core Image</code>(滤镜等),可以先看看<strong>objc.io</strong>第21期和第23期的有关介绍.  </p>
<p>#<font color="IndianRed">初始化视频捕捉</font><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 初始化视频捕获</span></span><br><span class="line">    private func initCapture() &#123;</span><br><span class="line">        <span class="comment">// 代表抽象的硬件设备,这里传入video</span></span><br><span class="line">        let captureDevice = <span class="built_in">AVCaptureDevice</span><span class="variable">.defaultDeviceWithMediaType</span>(<span class="built_in">AVMediaTypeVideo</span>)</span><br><span class="line">        var error: <span class="built_in">NSError</span>?</span><br><span class="line">        <span class="comment">// 输入流</span></span><br><span class="line">        var captureInput = <span class="built_in">AVCaptureDeviceInput</span><span class="variable">.deviceInputWithDevice</span>(captureDevice, error: &amp;error) as? <span class="built_in">AVCaptureDeviceInput</span></span><br><span class="line">        <span class="keyword">if</span> (error != <span class="literal">nil</span> &amp;&amp; captureInput == <span class="literal">nil</span>) &#123;</span><br><span class="line">            let errorAlert = <span class="built_in">UIAlertController</span>(title: <span class="string">"提醒"</span>, message: <span class="string">"请在iPhone的\"设置-隐私-相机\"选项中,允许XXX访问您的相机"</span>, preferredStyle: <span class="variable">.Alert</span>)</span><br><span class="line">            errorAlert<span class="variable">.addAction</span>(<span class="built_in">UIAlertAction</span>(title: <span class="string">"确定"</span>, style: <span class="built_in">UIAlertActionStyle</span><span class="variable">.Default</span>, handler: <span class="literal">nil</span>))</span><br><span class="line">            <span class="keyword">self</span><span class="variable">.presentViewController</span>(errorAlert, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// input和output的桥梁,它协调着intput到output的数据传输.(见字意,session-会话)</span></span><br><span class="line">            captureSession = <span class="built_in">AVCaptureSession</span>()</span><br><span class="line">            captureSession!<span class="variable">.addInput</span>(captureInput)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 输出流</span></span><br><span class="line">            let captureMetadataOutput = <span class="built_in">AVCaptureMetadataOutput</span>()</span><br><span class="line">            <span class="comment">// 限制扫描区域http://blog.csdn.net/lc_obj/article/details/41549469</span></span><br><span class="line">            captureMetadataOutput<span class="variable">.rectOfInterest</span> = <span class="built_in">CGRectMake</span>(<span class="number">128.0</span>/ScreenWH<span class="variable">.screenHeight</span>, (ScreenWH<span class="variable">.screenWidth</span> - <span class="number">280.0</span>)/ScreenWH<span class="variable">.screenWidth</span> * <span class="number">2.0</span>, <span class="number">280.0</span>/ScreenWH<span class="variable">.screenHeight</span>, <span class="number">280.0</span>/ScreenWH<span class="variable">.screenWidth</span>)</span><br><span class="line">            captureSession!<span class="variable">.addOutput</span>(captureMetadataOutput)</span><br><span class="line">            <span class="comment">// 添加的队列按规定必须是串行</span></span><br><span class="line">            captureMetadataOutput<span class="variable">.setMetadataObjectsDelegate</span>(<span class="keyword">self</span>, queue: dispatch_get_main_queue())</span><br><span class="line">            <span class="comment">// 指定信息类型,QRCode,你懂的</span></span><br><span class="line">            captureMetadataOutput<span class="variable">.metadataObjectTypes</span> = [<span class="built_in">AVMetadataObjectTypeQRCode</span>]</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 用这个预览图层和图像信息捕获会话(session)来显示视频</span></span><br><span class="line">            videoPreviewLayer = <span class="built_in">AVCaptureVideoPreviewLayer</span>(session: captureSession!)</span><br><span class="line">            videoPreviewLayer!<span class="variable">.videoGravity</span> = <span class="built_in">AVLayerVideoGravityResizeAspectFill</span></span><br><span class="line">            videoPreviewLayer!<span class="variable">.frame</span> = view<span class="variable">.bounds</span></span><br><span class="line">            view<span class="variable">.layer</span><span class="variable">.addSublayer</span>(videoPreviewLayer!)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">```  </span><br><span class="line">**PS:LZ用了下微信和新浪微博的扫一扫,发现那个扫描框是忽悠人的,也就是你没拿它对准二维码,只要二维码进入手机摄像头范围,就能够解码成功....囧**  </span><br><span class="line">所以LZ在代码中做了一个扫描区域的限制(感觉蛮无聊的)  </span><br><span class="line">&lt;!--more--&gt;   </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="preprocessor">#<span class="title">&lt;font color="IndianRed"&gt;</span>实现代理解码<span class="title">&lt;/font&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<pre><code>// MARK: - AVCaptureMetadataOutputObjectsDelegate
func captureOutput(captureOutput: AVCaptureOutput!, didOutputMetadataObjects metadataObjects: [AnyObject]!, fromConnection connection: AVCaptureConnection!) {
    if metadataObjects == nil || metadataObjects.count == 0 {
        captureView!.frame = CGRectZero
        return
    }
    // 刷取出来的数据
    for metadataObject in metadataObjects {
        if metadataObject.type == AVMetadataObjectTypeQRCode {
            let metadata = metadataObject as! AVMetadataMachineReadableCodeObject
            // 元数据对象就会被转化成图层的坐标
            let codeCoord = videoPreviewLayer!.transformedMetadataObjectForMetadataObject(metadata) as! AVMetadataMachineReadableCodeObject
            captureView!.frame = codeCoord.bounds
            if metadata.stringValue != nil {
                println(&quot;\(metadata.stringValue)&quot;)
                self.captureSession!.stopRunning()
                let successAlert = UIAlertController(title:&quot;提示&quot;, message:&quot;是否打开&quot; + metadata.stringValue, preferredStyle: .Alert)
                successAlert.addAction(UIAlertAction(title:&quot;取消&quot;, style: .Default, handler: { (_) -&gt; Void in
                    self.stopCapture()
                }))
                successAlert.addAction(UIAlertAction(title:&quot;确定&quot;, style: .Default, handler: { (_) -&gt; Void in
                    if metadata.stringValue.lowercaseString.hasPrefix(&quot;http&quot;) {
                        UIApplication.sharedApplication().openURL(NSURL(string: metadata.stringValue)!)
                        self.navigationController!.popViewControllerAnimated(true)
                    }
                }))
                self.presentViewController(successAlert, animated: true, completion: nil)
            }
        }
    }
}
</code></pre><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">数据转换`<span class="built_in">AVMetadataMachineReadableCodeObject</span>`对应二维码.  </span><br><span class="line">   </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="preprocessor">#<span class="title">&lt;font color="IndianRed"&gt;</span>生成二维码<span class="title">&lt;/font&gt;</span></span></span><br></pre></td></tr></table></figure>
<pre><code>// MARK: - Private Methods
private func createQRForString(qrString: String?, qrImageName: String?) -&gt; UIImage?{
    if let sureQRString = qrString {
        let stringData = sureQRString.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)
        // 创建一个二维码的滤镜
        let qrFilter = CIFilter(name: &quot;CIQRCodeGenerator&quot;)
        qrFilter.setValue(stringData, forKey: &quot;inputMessage&quot;)
        qrFilter.setValue(&quot;H&quot;, forKey: &quot;inputCorrectionLevel&quot;)
        let qrCIImage = qrFilter.outputImage
        // 创建一个颜色滤镜,黑白色
        let colorFilter = CIFilter(name: &quot;CIFalseColor&quot;)
        colorFilter.setDefaults()
        colorFilter.setValue(qrCIImage, forKey: &quot;inputImage&quot;)
        colorFilter.setValue(CIColor(red: 0, green: 0, blue: 0), forKey: &quot;inputColor0&quot;)
        colorFilter.setValue(CIColor(red: 1, green: 1, blue: 1), forKey: &quot;inputColor1&quot;)
        // 返回二维码image
        let codeImage = UIImage(CIImage: colorFilter.outputImage.imageByApplyingTransform(CGAffineTransformMakeScale(5, 5)))
        // 通常,二维码都是定制的,中间都会放想要表达意思的图片
        if let iconImage = UIImage(named: qrImageName!) {
            let rect = CGRectMake(0, 0, codeImage!.size.width, codeImage!.size.height)
            UIGraphicsBeginImageContext(rect.size)

            codeImage!.drawInRect(rect)
            let avatarSize = CGSizeMake(rect.size.width * 0.25, rect.size.height * 0.25)
            let x = (rect.width - avatarSize.width) * 0.5
            let y = (rect.height - avatarSize.height) * 0.5
            iconImage.drawInRect(CGRectMake(x, y, avatarSize.width, avatarSize.height))
            let resultImage = UIGraphicsGetImageFromCurrentImageContext()

            UIGraphicsEndImageContext()
            return resultImage
        }
        return codeImage
    }
    return nil
}
</code></pre><p>```<br>如图<br><img src="http://7qn7zn.com1.z0.glb.clouddn.com/qrcode_2.PNG" alt="">  </p>
<p><strong>结尾:<code>AVFoundation</code>这个框架特别的强大,也可以用它来写自定义相机,拍照和录制视频等</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>项目终于不需要支持iOS6了(泪崩),在二维码扫描这一块,能够完全的放弃<code>ZXing</code>库,改用系统的<code>AVFoundation</code>了,拿<code>swift</code>写了个Demo,效果如下:<br><strong>githu]]>
    </summary>
    
      <category term="AVFoundation 二维码" scheme="http://hmttommy.com/tags/AVFoundation-%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    
      <category term="Swift" scheme="http://hmttommy.com/categories/Swift/"/>
    
  </entry>
  
</feed>
